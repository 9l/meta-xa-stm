diff --git a/drivers/scsi/mpt3sas/Kconfig b/drivers/scsi/mpt3sas/Kconfig
index 4d235dd..7ecb425 100644
--- a/drivers/scsi/mpt3sas/Kconfig
+++ b/drivers/scsi/mpt3sas/Kconfig
@@ -65,3 +65,10 @@ config SCSI_MPT3SAS_LOGGING
 	depends on PCI && SCSI && SCSI_MPT3SAS
 	---help---
 	This turns on a logging facility.
+
+config SCSI_MPT3SAS_STM
+	tristate "LSI MPT3SAS Target Mode API"
+	depends on SCSI_MPT3SAS && m
+	---help---
+	This enables target mode support in the driver.
+
diff --git a/drivers/scsi/mpt3sas/Makefile b/drivers/scsi/mpt3sas/Makefile
index efb0c4c..dba9e25 100644
--- a/drivers/scsi/mpt3sas/Makefile
+++ b/drivers/scsi/mpt3sas/Makefile
@@ -6,3 +6,8 @@ mpt3sas-y +=  mpt3sas_base.o     \
 		mpt3sas_transport.o     \
 		mpt3sas_ctl.o	\
 		mpt3sas_trigger_diag.o
+
+ifdef CONFIG_SCSI_MPT3SAS_STM
+obj-m += mpt3sas_stm.o
+ccflags-y += -DCONFIG_SCSI_MPT3SAS_STM
+endif
diff --git a/drivers/scsi/mpt3sas/mpi/mpi2_targ.h b/drivers/scsi/mpt3sas/mpi/mpi2_targ.h
new file mode 100644
index 0000000..9b3f2aa
--- /dev/null
+++ b/drivers/scsi/mpt3sas/mpi/mpi2_targ.h
@@ -0,0 +1,570 @@
+/*
+ *  Copyright (c) 2000-2014 LSI Corporation.
+ *
+ *
+ *           Name:  mpi2_targ.h
+ *          Title:  MPI Target mode messages and structures
+ *  Creation Date:  September 8, 2006
+ *
+ *  mpi2_targ.h Version: 02.00.07
+ *
+ *  NOTE: Names (typedefs, defines, etc.) beginning with an MPI25 or Mpi25
+ *        prefix are for use only on MPI v2.5 products, and must not be used
+ *        with MPI v2.0 products. Unless otherwise noted, names beginning with
+ *        MPI2 or Mpi2 are for use with both MPI v2.0 and MPI v2.5 products.
+ *
+ *  Version History
+ *  ---------------
+ *
+ *  Date      Version   Description
+ *  --------  --------  ------------------------------------------------------
+ *  04-30-07  02.00.00  Corresponds to Fusion-MPT MPI Specification Rev A.
+ *  08-31-07  02.00.01  Added Command Buffer Data Location Address Space bits to
+ *                      BufferPostFlags field of CommandBufferPostBase Request.
+ *  02-29-08  02.00.02  Modified various names to make them 32-character unique.
+ *  10-02-08  02.00.03  Removed NextCmdBufferOffset from
+ *                      MPI2_TARGET_CMD_BUF_POST_BASE_REQUEST.
+ *                      Target Status Send Request only takes a single SGE for
+ *                      response data.
+ *  02-10-10  02.00.04  Added comment to MPI2_TARGET_SSP_RSP_IU structure.
+ *  11-18-11  02.00.05  Incorporating additions for MPI v2.5.
+ *  11-27-12  02.00.06  Added InitiatorDevHandle field to MPI2_TARGET_MODE_ABORT
+ *                      request message structure.
+ *                      Added AbortType MPI2_TARGET_MODE_ABORT_DEVHANDLE and
+ *                      MPI2_TARGET_MODE_ABORT_ALL_COMMANDS.
+ *  06-13-14  02.00.07  Added MinMSIxIndex and MaxMSIxIndex fields to
+ *                      MPI2_TARGET_CMD_BUF_POST_BASE_REQUEST.
+ *  --------------------------------------------------------------------------
+ */
+
+#ifndef MPI2_TARG_H
+#define MPI2_TARG_H
+
+
+/******************************************************************************
+*
+*        SCSI Target Messages
+*
+*******************************************************************************/
+
+/****************************************************************************
+*  Target Command Buffer Post Base Request
+****************************************************************************/
+
+typedef struct _MPI2_TARGET_CMD_BUF_POST_BASE_REQUEST
+{
+    U8                      BufferPostFlags;        /* 0x00 */
+    U8                      Reserved1;              /* 0x01 */
+    U8                      ChainOffset;            /* 0x02 */
+    U8                      Function;               /* 0x03 */
+    U16                     TotalCmdBuffers;        /* 0x04 */
+    U8                      Reserved;               /* 0x06 */
+    U8                      MsgFlags;               /* 0x07 */
+    U8                      VP_ID;                  /* 0x08 */
+    U8                      VF_ID;                  /* 0x09 */
+    U16                     Reserved2;              /* 0x0A */
+    U32                     Reserved3;              /* 0x0C */
+    U16                     CmdBufferLength;        /* 0x10 */
+    U8                      MinMSIxIndex;           /* 0x12 */ /* MPI 2.5 and newer only; Reserved in MPI 2.0 */
+    U8                      MaxMSIxIndex;           /* 0x13 */ /* MPI 2.5 and newer only; Reserved in MPI 2.0 */
+    U32                     BaseAddressLow;         /* 0x14 */
+    U32                     BaseAddressHigh;        /* 0x18 */
+} MPI2_TARGET_CMD_BUF_POST_BASE_REQUEST,
+  MPI2_POINTER PTR_MPI2_TARGET_CMD_BUF_POST_BASE_REQUEST,
+  Mpi2TargetCmdBufferPostBaseRequest_t,
+  MPI2_POINTER pMpi2TargetCmdBufferPostBaseRequest_t;
+
+/* values for the BufferPostflags field */
+#define MPI2_CMD_BUF_POST_BASE_ADDRESS_SPACE_MASK            (0x0C)
+#define MPI2_CMD_BUF_POST_BASE_SYSTEM_ADDRESS_SPACE          (0x00)
+#define MPI2_CMD_BUF_POST_BASE_IOCDDR_ADDRESS_SPACE          (0x04)
+#define MPI2_CMD_BUF_POST_BASE_IOCPLB_ADDRESS_SPACE          (0x08)
+#define MPI2_CMD_BUF_POST_BASE_IOCPLBNTA_ADDRESS_SPACE       (0x0C)
+
+#define MPI2_CMD_BUF_POST_BASE_FLAGS_AUTO_POST_ALL           (0x01)
+
+
+/****************************************************************************
+*  Target Command Buffer Post List Request
+****************************************************************************/
+
+typedef struct _MPI2_TARGET_CMD_BUF_POST_LIST_REQUEST
+{
+    U16                     Reserved;               /* 0x00 */
+    U8                      ChainOffset;            /* 0x02 */
+    U8                      Function;               /* 0x03 */
+    U16                     CmdBufferCount;         /* 0x04 */
+    U8                      Reserved1;              /* 0x06 */
+    U8                      MsgFlags;               /* 0x07 */
+    U8                      VP_ID;                  /* 0x08 */
+    U8                      VF_ID;                  /* 0x09 */
+    U16                     Reserved2;              /* 0x0A */
+    U32                     Reserved3;              /* 0x0C */
+    U16                     IoIndex[2];             /* 0x10 */
+} MPI2_TARGET_CMD_BUF_POST_LIST_REQUEST,
+  MPI2_POINTER PTR_MPI2_TARGET_CMD_BUF_POST_LIST_REQUEST,
+  Mpi2TargetCmdBufferPostListRequest_t,
+  MPI2_POINTER pMpi2TargetCmdBufferPostListRequest_t;
+
+/****************************************************************************
+*  Target Command Buffer Post Base List Reply
+****************************************************************************/
+
+typedef struct _MPI2_TARGET_BUF_POST_BASE_LIST_REPLY
+{
+    U8                      Flags;                  /* 0x00 */
+    U8                      Reserved;               /* 0x01 */
+    U8                      MsgLength;              /* 0x02 */
+    U8                      Function;               /* 0x03 */
+    U16                     Reserved1;              /* 0x04 */
+    U8                      Reserved2;              /* 0x06 */
+    U8                      MsgFlags;               /* 0x07 */
+    U8                      VP_ID;                  /* 0x08 */
+    U8                      VF_ID;                  /* 0x09 */
+    U16                     Reserved3;              /* 0x0A */
+    U16                     Reserved4;              /* 0x0C */
+    U16                     IOCStatus;              /* 0x0E */
+    U32                     IOCLogInfo;             /* 0x10 */
+    U16                     IoIndex;                /* 0x14 */
+    U16                     Reserved5;              /* 0x16 */
+    U32                     Reserved6;              /* 0x18 */
+} MPI2_TARGET_BUF_POST_BASE_LIST_REPLY,
+  MPI2_POINTER PTR_MPI2_TARGET_BUF_POST_BASE_LIST_REPLY,
+  Mpi2TargetCmdBufferPostBaseListReply_t,
+  MPI2_POINTER pMpi2TargetCmdBufferPostBaseListReply_t;
+
+/* Flags defines */
+#define MPI2_CMD_BUF_POST_REPLY_IOINDEX_VALID       (0x01)
+
+
+/****************************************************************************
+*  Command Buffer Formats (with 16 byte CDB)
+****************************************************************************/
+
+typedef struct _MPI2_TARGET_SSP_CMD_BUFFER
+{
+    U8      FrameType;                                  /* 0x00 */
+    U8      Reserved1;                                  /* 0x01 */
+    U16     InitiatorConnectionTag;                     /* 0x02 */
+    U32     HashedSourceSASAddress;                     /* 0x04 */
+    U16     Reserved2;                                  /* 0x08 */
+    U16     Flags;                                      /* 0x0A */
+    U32     Reserved3;                                  /* 0x0C */
+    U16     Tag;                                        /* 0x10 */
+    U16     TargetPortTransferTag;                      /* 0x12 */
+    U32     DataOffset;                                 /* 0x14 */
+    /* COMMAND information unit starts here */
+    U8      LogicalUnitNumber[8];                       /* 0x18 */
+    U8      Reserved4;                                  /* 0x20 */
+    U8      TaskAttribute; /* lower 3 bits */           /* 0x21 */
+    U8      Reserved5;                                  /* 0x22 */
+    U8      AdditionalCDBLength; /* upper 5 bits */     /* 0x23 */
+    U8      CDB[16];                                    /* 0x24 */
+    /* Additional CDB bytes extend past the CDB field */
+} MPI2_TARGET_SSP_CMD_BUFFER, MPI2_POINTER PTR_MPI2_TARGET_SSP_CMD_BUFFER,
+  Mpi2TargetSspCmdBuffer, MPI2_POINTER pMp2iTargetSspCmdBuffer;
+
+typedef struct _MPI2_TARGET_SSP_TASK_BUFFER
+{
+    U8      FrameType;                                  /* 0x00 */
+    U8      Reserved1;                                  /* 0x01 */
+    U16     InitiatorConnectionTag;                     /* 0x02 */
+    U32     HashedSourceSASAddress;                     /* 0x04 */
+    U16     Reserved2;                                  /* 0x08 */
+    U16     Flags;                                      /* 0x0A */
+    U32     Reserved3;                                  /* 0x0C */
+    U16     Tag;                                        /* 0x10 */
+    U16     TargetPortTransferTag;                      /* 0x12 */
+    U32     DataOffset;                                 /* 0x14 */
+    /* TASK information unit starts here */
+    U8      LogicalUnitNumber[8];                       /* 0x18 */
+    U16     Reserved4;                                  /* 0x20 */
+    U8      TaskManagementFunction;                     /* 0x22 */
+    U8      Reserved5;                                  /* 0x23 */
+    U16     ManagedTaskTag;                             /* 0x24 */
+    U16     Reserved6;                                  /* 0x26 */
+    U32     Reserved7;                                  /* 0x28 */
+    U32     Reserved8;                                  /* 0x2C */
+    U32     Reserved9;                                  /* 0x30 */
+} MPI2_TARGET_SSP_TASK_BUFFER, MPI2_POINTER PTR_MPI2_TARGET_SSP_TASK_BUFFER,
+  Mpi2TargetSspTaskBuffer, MPI2_POINTER pMpi2TargetSspTaskBuffer;
+
+/* mask and shift for HashedSourceSASAddress field */
+#define MPI2_TARGET_HASHED_SAS_ADDRESS_MASK     (0xFFFFFF00)
+#define MPI2_TARGET_HASHED_SAS_ADDRESS_SHIFT    (8)
+
+
+/****************************************************************************
+*   MPI v2.0 Target Assist Request
+****************************************************************************/
+
+typedef struct _MPI2_TARGET_ASSIST_REQUEST
+{
+    U8                  Reserved1;                          /* 0x00 */
+    U8                  TargetAssistFlags;                  /* 0x01 */
+    U8                  ChainOffset;                        /* 0x02 */
+    U8                  Function;                           /* 0x03 */
+    U16                 QueueTag;                           /* 0x04 */
+    U8                  Reserved2;                          /* 0x06 */
+    U8                  MsgFlags;                           /* 0x07 */
+    U8                  VP_ID;                              /* 0x08 */
+    U8                  VF_ID;                              /* 0x09 */
+    U16                 Reserved3;                          /* 0x0A */
+    U16                 IoIndex;                            /* 0x0C */
+    U16                 InitiatorConnectionTag;             /* 0x0E */
+    U16                 SGLFlags;                           /* 0x10 */
+    U8                  SequenceNumber;                     /* 0x12 */
+    U8                  Reserved4;                          /* 0x13 */
+    U8                  SGLOffset0;                         /* 0x14 */
+    U8                  SGLOffset1;                         /* 0x15 */
+    U8                  SGLOffset2;                         /* 0x16 */
+    U8                  SGLOffset3;                         /* 0x17 */
+    U32                 SkipCount;                          /* 0x18 */
+    U32                 DataLength;                         /* 0x1C */
+    U32                 BidirectionalDataLength;            /* 0x20 */
+    U16                 IoFlags;                            /* 0x24 */
+    U16                 EEDPFlags;                          /* 0x26 */
+    U32                 EEDPBlockSize;                      /* 0x28 */
+    U32                 SecondaryReferenceTag;              /* 0x2C */
+    U16                 SecondaryApplicationTag;            /* 0x30 */
+    U16                 ApplicationTagTranslationMask;      /* 0x32 */
+    U32                 PrimaryReferenceTag;                /* 0x34 */
+    U16                 PrimaryApplicationTag;              /* 0x38 */
+    U16                 PrimaryApplicationTagMask;          /* 0x3A */
+    U32                 RelativeOffset;                     /* 0x3C */
+    U32                 Reserved5;                          /* 0x40 */
+    U32                 Reserved6;                          /* 0x44 */
+    U32                 Reserved7;                          /* 0x48 */
+    U32                 Reserved8;                          /* 0x4C */
+    MPI2_SGE_IO_UNION   SGL[1];                             /* 0x50 */
+} MPI2_TARGET_ASSIST_REQUEST, MPI2_POINTER PTR_MPI2_TARGET_ASSIST_REQUEST,
+  Mpi2TargetAssistRequest_t, MPI2_POINTER pMpi2TargetAssistRequest_t;
+
+/* Target Assist TargetAssistFlags bits */
+
+#define MPI2_TARGET_ASSIST_FLAGS_REPOST_CMD_BUFFER      (0x80)
+#define MPI2_TARGET_ASSIST_FLAGS_TLR                    (0x10)
+#define MPI2_TARGET_ASSIST_FLAGS_RETRANSMIT             (0x04)
+#define MPI2_TARGET_ASSIST_FLAGS_AUTO_STATUS            (0x02)
+#define MPI2_TARGET_ASSIST_FLAGS_DATA_DIRECTION         (0x01)
+
+/* Target Assist SGLFlags bits */
+
+/* base values for Data Location Address Space */
+#define MPI2_TARGET_ASSIST_SGLFLAGS_ADDR_MASK           (0x0C)
+#define MPI2_TARGET_ASSIST_SGLFLAGS_SYSTEM_ADDR         (0x00)
+#define MPI2_TARGET_ASSIST_SGLFLAGS_IOCDDR_ADDR         (0x04)
+#define MPI2_TARGET_ASSIST_SGLFLAGS_IOCPLB_ADDR         (0x08)
+#define MPI2_TARGET_ASSIST_SGLFLAGS_PLBNTA_ADDR         (0x0C)
+
+/* base values for Type */
+#define MPI2_TARGET_ASSIST_SGLFLAGS_TYPE_MASK           (0x03)
+#define MPI2_TARGET_ASSIST_SGLFLAGS_MPI_TYPE            (0x00)
+#define MPI2_TARGET_ASSIST_SGLFLAGS_32IEEE_TYPE         (0x01)
+#define MPI2_TARGET_ASSIST_SGLFLAGS_64IEEE_TYPE         (0x02)
+
+/* shift values for each sub-field */
+#define MPI2_TARGET_ASSIST_SGLFLAGS_SGL3_SHIFT          (12)
+#define MPI2_TARGET_ASSIST_SGLFLAGS_SGL2_SHIFT          (8)
+#define MPI2_TARGET_ASSIST_SGLFLAGS_SGL1_SHIFT          (4)
+#define MPI2_TARGET_ASSIST_SGLFLAGS_SGL0_SHIFT          (0)
+
+/* Target Assist IoFlags bits */
+
+#define MPI2_TARGET_ASSIST_IOFLAGS_BIDIRECTIONAL        (0x0800)
+#define MPI2_TARGET_ASSIST_IOFLAGS_MULTICAST            (0x0400)
+#define MPI2_TARGET_ASSIST_IOFLAGS_RECEIVE_FIRST        (0x0200)
+
+/* Target Assist EEDPFlags bits */
+
+#define MPI2_TA_EEDPFLAGS_INC_PRI_REFTAG            (0x8000)
+#define MPI2_TA_EEDPFLAGS_INC_SEC_REFTAG            (0x4000)
+#define MPI2_TA_EEDPFLAGS_INC_PRI_APPTAG            (0x2000)
+#define MPI2_TA_EEDPFLAGS_INC_SEC_APPTAG            (0x1000)
+
+#define MPI2_TA_EEDPFLAGS_CHECK_REFTAG              (0x0400)
+#define MPI2_TA_EEDPFLAGS_CHECK_APPTAG              (0x0200)
+#define MPI2_TA_EEDPFLAGS_CHECK_GUARD               (0x0100)
+
+#define MPI2_TA_EEDPFLAGS_PASSTHRU_REFTAG           (0x0008)
+
+#define MPI2_TA_EEDPFLAGS_MASK_OP                   (0x0007)
+#define MPI2_TA_EEDPFLAGS_NOOP_OP                   (0x0000)
+#define MPI2_TA_EEDPFLAGS_CHECK_OP                  (0x0001)
+#define MPI2_TA_EEDPFLAGS_STRIP_OP                  (0x0002)
+#define MPI2_TA_EEDPFLAGS_CHECK_REMOVE_OP           (0x0003)
+#define MPI2_TA_EEDPFLAGS_INSERT_OP                 (0x0004)
+#define MPI2_TA_EEDPFLAGS_REPLACE_OP                (0x0006)
+#define MPI2_TA_EEDPFLAGS_CHECK_REGEN_OP            (0x0007)
+
+
+/****************************************************************************
+*   MPI v2.5 Target Assist Request
+****************************************************************************/
+
+typedef struct _MPI25_TARGET_ASSIST_REQUEST
+{
+    U8                  Reserved1;                          /* 0x00 */
+    U8                  TargetAssistFlags;                  /* 0x01 */
+    U8                  ChainOffset;                        /* 0x02 */
+    U8                  Function;                           /* 0x03 */
+    U16                 QueueTag;                           /* 0x04 */
+    U8                  Reserved2;                          /* 0x06 */
+    U8                  MsgFlags;                           /* 0x07 */
+    U8                  VP_ID;                              /* 0x08 */
+    U8                  VF_ID;                              /* 0x09 */
+    U16                 Reserved3;                          /* 0x0A */
+    U16                 IoIndex;                            /* 0x0C */
+    U16                 InitiatorConnectionTag;             /* 0x0E */
+    U8                  DMAFlags;                           /* 0x10 */
+    U8                  Reserved9;                          /* 0x11 */
+    U8                  SequenceNumber;                     /* 0x12 */
+    U8                  Reserved4;                          /* 0x13 */
+    U8                  SGLOffset0;                         /* 0x14 */
+    U8                  SGLOffset1;                         /* 0x15 */
+    U8                  SGLOffset2;                         /* 0x16 */
+    U8                  SGLOffset3;                         /* 0x17 */
+    U32                 SkipCount;                          /* 0x18 */
+    U32                 DataLength;                         /* 0x1C */
+    U32                 BidirectionalDataLength;            /* 0x20 */
+    U16                 IoFlags;                            /* 0x24 */
+    U16                 EEDPFlags;                          /* 0x26 */
+    U16                 EEDPBlockSize;                      /* 0x28 */
+    U16                 Reserved10;                         /* 0x2A */
+    U32                 SecondaryReferenceTag;              /* 0x2C */
+    U16                 SecondaryApplicationTag;            /* 0x30 */
+    U16                 ApplicationTagTranslationMask;      /* 0x32 */
+    U32                 PrimaryReferenceTag;                /* 0x34 */
+    U16                 PrimaryApplicationTag;              /* 0x38 */
+    U16                 PrimaryApplicationTagMask;          /* 0x3A */
+    U32                 RelativeOffset;                     /* 0x3C */
+    U32                 Reserved5;                          /* 0x40 */
+    U32                 Reserved6;                          /* 0x44 */
+    U32                 Reserved7;                          /* 0x48 */
+    U32                 Reserved8;                          /* 0x4C */
+    MPI25_SGE_IO_UNION  SGL;                                /* 0x50 */
+} MPI25_TARGET_ASSIST_REQUEST, MPI2_POINTER PTR_MPI25_TARGET_ASSIST_REQUEST,
+  Mpi25TargetAssistRequest_t, MPI2_POINTER pMpi25TargetAssistRequest_t;
+
+/* use MPI2_TARGET_ASSIST_FLAGS_ defines for the Flags field */
+
+/* Defines for the DMAFlags field
+ *  Each setting affects 4 SGLS, from SGL0 to SGL3.
+ *      D = Data
+ *      C = Cache DIF
+ *      I = Interleaved
+ *      H = Host DIF
+ */
+#define MPI25_TA_DMAFLAGS_OP_MASK                   (0x0F)
+#define MPI25_TA_DMAFLAGS_OP_D_D_D_D                (0x00)
+#define MPI25_TA_DMAFLAGS_OP_D_D_D_C                (0x01)
+#define MPI25_TA_DMAFLAGS_OP_D_D_D_I                (0x02)
+#define MPI25_TA_DMAFLAGS_OP_D_D_C_C                (0x03)
+#define MPI25_TA_DMAFLAGS_OP_D_D_C_I                (0x04)
+#define MPI25_TA_DMAFLAGS_OP_D_D_I_I                (0x05)
+#define MPI25_TA_DMAFLAGS_OP_D_C_C_C                (0x06)
+#define MPI25_TA_DMAFLAGS_OP_D_C_C_I                (0x07)
+#define MPI25_TA_DMAFLAGS_OP_D_C_I_I                (0x08)
+#define MPI25_TA_DMAFLAGS_OP_D_I_I_I                (0x09)
+#define MPI25_TA_DMAFLAGS_OP_D_H_D_D                (0x0A)
+#define MPI25_TA_DMAFLAGS_OP_D_H_D_C                (0x0B)
+#define MPI25_TA_DMAFLAGS_OP_D_H_D_I                (0x0C)
+#define MPI25_TA_DMAFLAGS_OP_D_H_C_C                (0x0D)
+#define MPI25_TA_DMAFLAGS_OP_D_H_C_I                (0x0E)
+#define MPI25_TA_DMAFLAGS_OP_D_H_I_I                (0x0F)
+
+/* defines for the IoFlags field */
+#define MPI25_TARGET_ASSIST_IOFLAGS_BIDIRECTIONAL       (0x0800)
+#define MPI25_TARGET_ASSIST_IOFLAGS_RECEIVE_FIRST       (0x0200)
+
+/* defines for the EEDPFlags field */
+#define MPI25_TA_EEDPFLAGS_INC_PRI_REFTAG               (0x8000)
+#define MPI25_TA_EEDPFLAGS_INC_SEC_REFTAG               (0x4000)
+#define MPI25_TA_EEDPFLAGS_INC_PRI_APPTAG               (0x2000)
+#define MPI25_TA_EEDPFLAGS_INC_SEC_APPTAG               (0x1000)
+
+#define MPI25_TA_EEDPFLAGS_CHECK_REFTAG                 (0x0400)
+#define MPI25_TA_EEDPFLAGS_CHECK_APPTAG                 (0x0200)
+#define MPI25_TA_EEDPFLAGS_CHECK_GUARD                  (0x0100)
+
+#define MPI25_TA_EEDPFLAGS_ESCAPE_MODE_MASK             (0x00C0)
+#define MPI25_TA_EEDPFLAGS_COMPATIBLE_MODE              (0x0000)
+#define MPI25_TA_EEDPFLAGS_DO_NOT_DISABLE_MODE          (0x0040)
+#define MPI25_TA_EEDPFLAGS_APPTAG_DISABLE_MODE          (0x0080)
+#define MPI25_TA_EEDPFLAGS_APPTAG_REFTAG_DISABLE_MODE   (0x00C0)
+
+#define MPI25_TA_EEDPFLAGS_HOST_GUARD_METHOD_MASK       (0x0030)
+#define MPI25_TA_EEDPFLAGS_T10_CRC_HOST_GUARD           (0x0000)
+#define MPI25_TA_EEDPFLAGS_IP_CHKSUM_HOST_GUARD         (0x0010)
+
+#define MPI25_TA_EEDPFLAGS_PASSTHRU_REFTAG              (0x0008)
+
+#define MPI25_TA_EEDPFLAGS_MASK_OP                      (0x0007)
+#define MPI25_TA_EEDPFLAGS_NOOP_OP                      (0x0000)
+#define MPI25_TA_EEDPFLAGS_CHECK_OP                     (0x0001)
+#define MPI25_TA_EEDPFLAGS_STRIP_OP                     (0x0002)
+#define MPI25_TA_EEDPFLAGS_CHECK_REMOVE_OP              (0x0003)
+#define MPI25_TA_EEDPFLAGS_INSERT_OP                    (0x0004)
+#define MPI25_TA_EEDPFLAGS_REPLACE_OP                   (0x0006)
+#define MPI25_TA_EEDPFLAGS_CHECK_REGEN_OP               (0x0007)
+
+
+/****************************************************************************
+*  Target Status Send Request
+****************************************************************************/
+
+typedef struct _MPI2_TARGET_STATUS_SEND_REQUEST
+{
+    U8                      Reserved1;                  /* 0x00 */
+    U8                      StatusFlags;                /* 0x01 */
+    U8                      ChainOffset;                /* 0x02 */
+    U8                      Function;                   /* 0x03 */
+    U16                     QueueTag;                   /* 0x04 */
+    U8                      Reserved2;                  /* 0x06 */
+    U8                      MsgFlags;                   /* 0x07 */
+    U8                      VP_ID;                      /* 0x08 */
+    U8                      VF_ID;                      /* 0x09 */
+    U16                     Reserved3;                  /* 0x0A */
+    U16                     IoIndex;                    /* 0x0C */
+    U16                     InitiatorConnectionTag;     /* 0x0E */
+    U16                     SGLFlags;                   /* 0x10 */ /* MPI v2.0 only. Reserved on MPI v2.5. */
+    U16                     Reserved4;                  /* 0x12 */
+    U8                      SGLOffset0;                 /* 0x14 */
+    U8                      Reserved5;                  /* 0x15 */
+    U16                     Reserved6;                  /* 0x16 */
+    U32                     Reserved7;                  /* 0x18 */
+    U32                     Reserved8;                  /* 0x1C */
+    MPI2_SIMPLE_SGE_UNION   StatusDataSGE;              /* 0x20 */ /* MPI v2.5: This must be an IEEE Simple Element 64. */
+} MPI2_TARGET_STATUS_SEND_REQUEST,
+  MPI2_POINTER PTR_MPI2_TARGET_STATUS_SEND_REQUEST,
+  Mpi2TargetStatusSendRequest_t, MPI2_POINTER pMpi2TargetStatusSendRequest_t;
+
+/* Target Status Send StatusFlags bits */
+
+#define MPI2_TSS_FLAGS_REPOST_CMD_BUFFER            (0x80)
+#define MPI2_TSS_FLAGS_RETRANSMIT                   (0x04)
+#define MPI2_TSS_FLAGS_AUTO_GOOD_STATUS             (0x01)
+
+/* Target Status Send SGLFlags bits - MPI v2.0 only */
+/* Data Location Address Space */
+#define MPI2_TSS_SGLFLAGS_ADDR_MASK                 (0x0C)
+#define MPI2_TSS_SGLFLAGS_SYSTEM_ADDR               (0x00)
+#define MPI2_TSS_SGLFLAGS_IOCDDR_ADDR               (0x04)
+#define MPI2_TSS_SGLFLAGS_IOCPLB_ADDR               (0x08)
+#define MPI2_TSS_SGLFLAGS_IOCPLBNTA_ADDR            (0x0C)
+/* Type */
+#define MPI2_TSS_SGLFLAGS_TYPE_MASK                 (0x03)
+#define MPI2_TSS_SGLFLAGS_MPI_TYPE                  (0x00)
+#define MPI2_TSS_SGLFLAGS_IEEE32_TYPE               (0x01)
+#define MPI2_TSS_SGLFLAGS_IEEE64_TYPE               (0x02)
+
+
+
+/*
+ * NOTE: The SSP status IU is big-endian. When used on a little-endian system,
+ * this structure properly orders the bytes.
+ */
+typedef struct _MPI2_TARGET_SSP_RSP_IU
+{
+    U32     Reserved0[6]; /* reserved for SSP header */ /* 0x00 */
+
+    /* start of RESPONSE information unit */
+    U32     Reserved1;                                  /* 0x18 */
+    U32     Reserved2;                                  /* 0x1C */
+    U16     Reserved3;                                  /* 0x20 */
+    U8      DataPres; /* lower 2 bits */                /* 0x22 */
+    U8      Status;                                     /* 0x23 */
+    U32     Reserved4;                                  /* 0x24 */
+    U32     SenseDataLength;                            /* 0x28 */
+    U32     ResponseDataLength;                         /* 0x2C */
+
+    /* start of Response or Sense Data (size may vary dynamically) */
+    U8      ResponseSenseData[4];                       /* 0x30 */
+} MPI2_TARGET_SSP_RSP_IU, MPI2_POINTER PTR_MPI2_TARGET_SSP_RSP_IU,
+  Mpi2TargetSspRspIu_t, MPI2_POINTER pMpi2TargetSspRspIu_t;
+
+
+/****************************************************************************
+*  Target Standard Reply - used with Target Assist or Target Status Send
+****************************************************************************/
+
+typedef struct _MPI2_TARGET_STANDARD_REPLY
+{
+    U16                     Reserved;                   /* 0x00 */
+    U8                      MsgLength;                  /* 0x02 */
+    U8                      Function;                   /* 0x03 */
+    U16                     Reserved1;                  /* 0x04 */
+    U8                      Reserved2;                  /* 0x06 */
+    U8                      MsgFlags;                   /* 0x07 */
+    U8                      VP_ID;                      /* 0x08 */
+    U8                      VF_ID;                      /* 0x09 */
+    U16                     Reserved3;                  /* 0x0A */
+    U16                     Reserved4;                  /* 0x0C */
+    U16                     IOCStatus;                  /* 0x0E */
+    U32                     IOCLogInfo;                 /* 0x10 */
+    U16                     IoIndex;                    /* 0x14 */
+    U16                     Reserved5;                  /* 0x16 */
+    U32                     TransferCount;              /* 0x18 */
+    U32                     BidirectionalTransferCount; /* 0x1C */
+} MPI2_TARGET_STANDARD_REPLY, MPI2_POINTER PTR_MPI2_TARGET_STANDARD_REPLY,
+  Mpi2TargetErrorReply_t, MPI2_POINTER pMpi2TargetErrorReply_t;
+
+
+/****************************************************************************
+*  Target Mode Abort Request
+****************************************************************************/
+
+typedef struct _MPI2_TARGET_MODE_ABORT_REQUEST
+{
+    U8                      AbortType;                  /* 0x00 */
+    U8                      Reserved1;                  /* 0x01 */
+    U8                      ChainOffset;                /* 0x02 */
+    U8                      Function;                   /* 0x03 */
+    U16                     Reserved2;                  /* 0x04 */
+    U8                      Reserved3;                  /* 0x06 */
+    U8                      MsgFlags;                   /* 0x07 */
+    U8                      VP_ID;                      /* 0x08 */
+    U8                      VF_ID;                      /* 0x09 */
+    U16                     Reserved4;                  /* 0x0A */
+    U16                     IoIndexToAbort;             /* 0x0C */
+    U16                     InitiatorDevHandle;         /* 0x0E */
+    U32                     MidToAbort;                 /* 0x10 */
+} MPI2_TARGET_MODE_ABORT, MPI2_POINTER PTR_MPI2_TARGET_MODE_ABORT,
+  Mpi2TargetModeAbort_t, MPI2_POINTER pMpi2TargetModeAbort_t;
+
+/* Target Mode Abort AbortType values */
+
+#define MPI2_TARGET_MODE_ABORT_ALL_CMD_BUFFERS      (0x00)
+#define MPI2_TARGET_MODE_ABORT_ALL_IO               (0x01)
+#define MPI2_TARGET_MODE_ABORT_EXACT_IO             (0x02)
+#define MPI2_TARGET_MODE_ABORT_EXACT_IO_REQUEST     (0x03)
+#define MPI2_TARGET_MODE_ABORT_IO_REQUEST_AND_IO    (0x04)
+#define MPI2_TARGET_MODE_ABORT_DEVHANDLE            (0x05)
+#define MPI2_TARGET_MODE_ABORT_ALL_COMMANDS         (0x06)
+
+
+/****************************************************************************
+*  Target Mode Abort Reply
+****************************************************************************/
+
+typedef struct _MPI2_TARGET_MODE_ABORT_REPLY
+{
+    U16                     Reserved;                   /* 0x00 */
+    U8                      MsgLength;                  /* 0x02 */
+    U8                      Function;                   /* 0x03 */
+    U16                     Reserved1;                  /* 0x04 */
+    U8                      Reserved2;                  /* 0x06 */
+    U8                      MsgFlags;                   /* 0x07 */
+    U8                      VP_ID;                      /* 0x08 */
+    U8                      VF_ID;                      /* 0x09 */
+    U16                     Reserved3;                  /* 0x0A */
+    U16                     Reserved4;                  /* 0x0C */
+    U16                     IOCStatus;                  /* 0x0E */
+    U32                     IOCLogInfo;                 /* 0x10 */
+    U32                     AbortCount;                 /* 0x14 */
+} MPI2_TARGET_MODE_ABORT_REPLY, MPI2_POINTER PTR_MPI2_TARGET_MODE_ABORT_REPLY,
+  Mpi2TargetModeAbortReply_t, MPI2_POINTER pMpi2TargetModeAbortReply_t;
+
+
+#endif
+
diff --git a/drivers/scsi/mpt3sas/mpi/mpi2_type.h b/drivers/scsi/mpt3sas/mpi/mpi2_type.h
index 99ab093..58062be 100644
--- a/drivers/scsi/mpt3sas/mpi/mpi2_type.h
+++ b/drivers/scsi/mpt3sas/mpi/mpi2_type.h
@@ -21,11 +21,14 @@
 #define MPI2_TYPE_H
 
 /*******************************************************************************
- * Define * if it hasn't already been defined. By default
- * * is defined to be a near pointer. MPI2_POINTER can be defined as
- * a far pointer by defining * as "far *" before this header file is
+ * Define MPI2_POINTER if it hasn't already been defined. By default
+ * MPI2_POINTER is defined to be a near pointer. MPI2_POINTER can be defined as
+ * a far pointer by defining MPI2_POINTER as "far *" before this header file is
  * included.
  */
+#ifndef MPI2_POINTER
+#define MPI2_POINTER     *
+#endif
 
 /* the basic types may have already been included by mpi_type.h */
 #ifndef MPI_TYPE_H
diff --git a/drivers/scsi/mpt3sas/mpt3sas_base.c b/drivers/scsi/mpt3sas/mpt3sas_base.c
index 14a781b..8d8a45d 100644
--- a/drivers/scsi/mpt3sas/mpt3sas_base.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_base.c
@@ -65,6 +65,10 @@
 
 static MPT_CALLBACK	mpt_callbacks[MPT_MAX_CALLBACKS];
 
+#if defined(CONFIG_SCSI_MPT3SAS_STM)
+static struct STM_CALLBACK stm_callbacks;
+EXPORT_SYMBOL(mpt3sas_ioc_list);
+#endif
 
 #define FAULT_POLLING_INTERVAL 1000 /* in milliseconds */
 
@@ -205,6 +209,12 @@ _base_fault_reset_work(struct work_struct *work)
 		if (rc && (doorbell & MPI2_IOC_STATE_MASK) !=
 		    MPI2_IOC_STATE_OPERATIONAL)
 			return; /* don't rearm timer */
+#if defined(CONFIG_SCSI_MPT3SAS_STM)
+    } else {
+        if (stm_callbacks.watchdog)
+            /* target mode drivers watchdog */
+            stm_callbacks.watchdog(ioc);
+#endif
 	}
 
 	spin_lock_irqsave(&ioc->ioc_reset_in_progress_lock, flags);
@@ -911,7 +921,7 @@ _base_interrupt(int irq, void *bus_id)
 	struct MPT3SAS_ADAPTER *ioc = reply_q->ioc;
 	Mpi2ReplyDescriptorsUnion_t *rpf;
 	u8 rc;
-
+    
 	if (ioc->mask_interrupts)
 		return IRQ_NONE;
 
@@ -937,7 +947,7 @@ _base_interrupt(int irq, void *bus_id)
 		if (request_desript_type ==
 		    MPI25_RPY_DESCRIPT_FLAGS_FAST_PATH_SCSI_IO_SUCCESS ||
 		    request_desript_type ==
-		    MPI2_RPY_DESCRIPT_FLAGS_SCSI_IO_SUCCESS) {
+		    MPI2_RPY_DESCRIPT_FLAGS_SCSI_IO_SUCCESS ) {
 			cb_idx = _base_get_cb_idx(ioc, smid);
 			if ((likely(cb_idx < MPT_MAX_CALLBACKS)) &&
 			    (likely(mpt_callbacks[cb_idx] != NULL))) {
@@ -946,6 +956,21 @@ _base_interrupt(int irq, void *bus_id)
 				if (rc)
 					mpt3sas_base_free_smid(ioc, smid);
 			}
+#if defined(CONFIG_SCSI_MPT3SAS_STM)
+        } else if (request_desript_type ==
+                   MPI2_RPY_DESCRIPT_FLAGS_TARGET_COMMAND_BUFFER) {
+            if (stm_callbacks.target_command)
+                stm_callbacks.target_command(ioc,
+                    &rpf->TargetCommandBuffer, msix_index);
+        } else if (request_desript_type ==
+                   MPI2_RPY_DESCRIPT_FLAGS_TARGETASSIST_SUCCESS) {
+            if (likely(stm_callbacks.target_assist)) {
+                rc = stm_callbacks.target_assist(ioc,
+                        &rpf->TargetAssistSuccess);
+                if (rc)
+                    mpt3sas_base_free_smid(ioc,smid);
+            }
+#endif
 		} else if (request_desript_type ==
 		    MPI2_RPY_DESCRIPT_FLAGS_ADDRESS_REPLY) {
 			reply = le32_to_cpu(
@@ -968,6 +993,10 @@ _base_interrupt(int irq, void *bus_id)
 				}
 			} else {
 				_base_async_event(ioc, msix_index, reply);
+#if defined(CONFIG_SCSI_MPT3SAS_STM)
+                if (stm_callbacks.event_handler)
+                    stm_callbacks.event_handler(ioc, msix_index, reply);
+#endif
 			}
 
 			/* reply free queue handling */
@@ -982,7 +1011,7 @@ _base_interrupt(int irq, void *bus_id)
 				writel(ioc->reply_free_host_index,
 				    &ioc->chip->ReplyFreeHostIndex);
 			}
-		}
+        }
 
 		rpf->Words = cpu_to_le64(ULLONG_MAX);
 		reply_q->reply_post_host_index =
@@ -1070,6 +1099,9 @@ mpt3sas_base_release_callback_handler(u8 cb_idx)
 {
 	mpt_callbacks[cb_idx] = NULL;
 }
+#if defined(CONFIG_SCSI_MPT3SAS_STM)
+EXPORT_SYMBOL(mpt3sas_base_release_callback_handler);
+#endif
 
 /**
  * mpt3sas_base_register_callback_handler - obtain index for the interrupt callback handler
@@ -1089,6 +1121,9 @@ mpt3sas_base_register_callback_handler(MPT_CALLBACK cb_func)
 	mpt_callbacks[cb_idx] = cb_func;
 	return cb_idx;
 }
+#if defined(CONFIG_SCSI_MPT3SAS_STM)
+EXPORT_SYMBOL(mpt3sas_base_register_callback_handler);
+#endif
 
 /**
  * mpt3sas_base_initialize_callback_handler - initialize the interrupt callback handler
@@ -1104,6 +1139,51 @@ mpt3sas_base_initialize_callback_handler(void)
 		mpt3sas_base_release_callback_handler(cb_idx);
 }
 
+#if defined(CONFIG_SCSI_MPT3SAS_STM)
+/**
+ * mpt3sas_base_stm_release_callback_handler - clear STM callback handler
+ *
+ * Return nothing.
+ */
+void
+mpt3sas_base_stm_release_callback_handler(void)
+{
+    stm_callbacks.watchdog = NULL;
+    stm_callbacks.target_command = NULL;
+    stm_callbacks.target_assist = NULL;
+    stm_callbacks.event_handler = NULL;
+    stm_callbacks.reset_handler = NULL;
+}
+EXPORT_SYMBOL(mpt3sas_base_stm_release_callback_handler);
+
+/**
+ * mpt3sas_base_stm_register_callback_handler - Set the STM callbacks
+ * @stm_funcs: Structure containing the function pointers
+ *
+ */
+void
+mpt3sas_base_stm_register_callback_handler(struct STM_CALLBACK stm_funcs)
+{
+    
+    stm_callbacks.watchdog = stm_funcs.watchdog;
+    stm_callbacks.target_command = stm_funcs.target_command;
+    stm_callbacks.target_assist = stm_funcs.target_assist;
+    stm_callbacks.event_handler = stm_funcs.event_handler;
+    stm_callbacks.reset_handler = stm_funcs.reset_handler;
+}
+EXPORT_SYMBOL(mpt3sas_base_stm_register_callback_handler);
+
+/**
+ * mpt3sas_base_stm_initialize_callback_handler - initialize the stm handler
+ *
+ * Return nothing.
+ */
+void
+mpt3sas_base_stm_initialize_callback_handler(void)
+{
+    mpt3sas_base_stm_release_callback_handler();
+}
+#endif
 
 /**
  * _base_build_zero_len_sge - build zero length sg entry
@@ -1916,6 +1996,9 @@ mpt3sas_base_get_msg_frame(struct MPT3SAS_ADAPTER *ioc, u16 smid)
 {
 	return (void *)(ioc->request + (smid * ioc->request_sz));
 }
+#if defined(CONFIG_SCSI_MPT3SAS_STM)
+EXPORT_SYMBOL(mpt3sas_base_get_msg_frame);
+#endif
 
 /**
  * mpt3sas_base_get_sense_buffer - obtain a sense buffer virt addr
@@ -1958,6 +2041,9 @@ mpt3sas_base_get_reply_virt_addr(struct MPT3SAS_ADAPTER *ioc, u32 phys_addr)
 		return NULL;
 	return ioc->reply + (phys_addr - (u32)ioc->reply_dma);
 }
+#if defined(CONFIG_SCSI_MPT3SAS_STM)
+EXPORT_SYMBOL(mpt3sas_base_get_reply_virt_addr);
+#endif
 
 /**
  * mpt3sas_base_get_smid - obtain a free smid from internal queue
@@ -1989,6 +2075,9 @@ mpt3sas_base_get_smid(struct MPT3SAS_ADAPTER *ioc, u8 cb_idx)
 	spin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);
 	return smid;
 }
+#if defined(CONFIG_SCSI_MPT3SAS_STM)
+EXPORT_SYMBOL(mpt3sas_base_get_smid);
+#endif
 
 /**
  * mpt3sas_base_get_smid_scsiio - obtain a free smid from scsiio queue
@@ -2023,6 +2112,9 @@ mpt3sas_base_get_smid_scsiio(struct MPT3SAS_ADAPTER *ioc, u8 cb_idx,
 	spin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);
 	return smid;
 }
+#if defined(CONFIG_SCSI_MPT3SAS_STM)
+EXPORT_SYMBOL(mpt3sas_base_get_smid_scsiio);
+#endif
 
 /**
  * mpt3sas_base_get_smid_hpr - obtain a free smid from hi-priority queue
@@ -2108,6 +2200,9 @@ mpt3sas_base_free_smid(struct MPT3SAS_ADAPTER *ioc, u16 smid)
 	}
 	spin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);
 }
+#if defined(CONFIG_SCSI_MPT3SAS_STM)
+EXPORT_SYMBOL(mpt3sas_base_free_smid);
+#endif
 
 /**
  * _base_writeq - 64 bit write to MMIO
@@ -2127,7 +2222,8 @@ _base_writeq(__u64 b, volatile void __iomem *addr, spinlock_t *writeq_lock)
 	writeq(cpu_to_le64(b), addr);
 }
 #else
-static inline void
+//static inline void
+static void
 _base_writeq(__u64 b, volatile void __iomem *addr, spinlock_t *writeq_lock)
 {
 	unsigned long flags;
@@ -2239,6 +2335,36 @@ mpt3sas_base_put_smid_default(struct MPT3SAS_ADAPTER *ioc, u16 smid)
 	_base_writeq(*request, &ioc->chip->RequestDescriptorPostLow,
 	    &ioc->scsi_lookup_lock);
 }
+#if defined(CONFIG_SCSI_MPT3SAS_STM)
+EXPORT_SYMBOL(mpt3sas_base_put_smid_default);
+#endif
+
+/**
+ * mpt3sas_base_put_smid_target - Target Assist and Target Status
+ * @ioc: per adapter object
+ * @smid: system request message index
+ * @io_index: value used to track the IO
+ *
+ * Return nothing.
+ */
+void
+mpt3sas_base_put_smid_target(struct MPT3SAS_ADAPTER *ioc, u16 smid, u16 io_index)
+{
+        Mpi2RequestDescriptorUnion_t descriptor;
+        u64 *request = (u64 *)&descriptor;
+
+	descriptor.SCSITarget.RequestFlags =
+	    MPI2_REQ_DESCRIPT_FLAGS_SCSI_TARGET;
+	descriptor.SCSITarget.MSIxIndex =  _base_get_msix_index(ioc);
+	descriptor.SCSITarget.SMID = cpu_to_le16(smid);
+	descriptor.SCSITarget.LMID = 0;
+	descriptor.SCSITarget.IoIndex = cpu_to_le16(io_index);
+        _base_writeq(*request, &ioc->chip->RequestDescriptorPostLow,
+            &ioc->scsi_lookup_lock);
+}
+#if defined(CONFIG_SCSI_MPT3SAS_STM)
+EXPORT_SYMBOL(mpt3sas_base_put_smid_target);
+#endif
 
 /**
  * _base_display_intel_branding - Display branding string
@@ -2668,12 +2794,19 @@ _base_allocate_memory_pools(struct MPT3SAS_ADAPTER *ioc,  int sleep_flag)
 	u16 max_request_credit;
 	unsigned short sg_tablesize;
 	u16 sge_size;
+#if defined(CONFIG_SCSI_MPT3SAS_STM)
+    int num_cmd_buffers;
+#endif
 	int i;
 
 	dinitprintk(ioc, pr_info(MPT3SAS_FMT "%s\n", ioc->name,
 	    __func__));
 
-
+#if defined(CONFIG_SCSI_MPT3SAS_STM)
+    num_cmd_buffers = min_t(int, NUM_CMD_BUFFERS,
+        ioc->pfacts[0].MaxPostedCmdBuffers);
+#endif
+    
 	retry_sz = 0;
 	facts = &ioc->facts;
 
@@ -2696,7 +2829,13 @@ _base_allocate_memory_pools(struct MPT3SAS_ADAPTER *ioc,  int sleep_flag)
 	ioc->shost->sg_tablesize = sg_tablesize;
 
 	ioc->hi_priority_depth = facts->HighPriorityCredit;
+#if defined(CONFIG_SCSI_MPT3SAS_STM)
+    /* allocating 5 extra mf's */
+    ioc->internal_depth = max_t(int, ioc->hi_priority_depth,
+                                num_cmd_buffers) + (5);
+#else
 	ioc->internal_depth = ioc->hi_priority_depth + (5);
+#endif
 	/* command line tunables  for max controller queue depth */
 	if (max_queue_depth != -1 && max_queue_depth != 0) {
 		max_request_credit = min_t(u16, max_queue_depth +
@@ -2837,7 +2976,12 @@ _base_allocate_memory_pools(struct MPT3SAS_ADAPTER *ioc,  int sleep_flag)
 	/* set the scsi host can_queue depth
 	 * with some internal commands that could be outstanding
 	 */
+#if defined(CONFIG_SCSI_MPT3SAS_STM)
+    /* allocating 2 extra mf's */
+    ioc->shost->can_queue = ioc->scsiio_depth - num_cmd_buffers;
+#else
 	ioc->shost->can_queue = ioc->scsiio_depth;
+#endif
 	dinitprintk(ioc, pr_info(MPT3SAS_FMT
 		"scsi host: can_queue depth (%d)\n",
 		ioc->name, ioc->shost->can_queue));
@@ -3091,6 +3235,9 @@ mpt3sas_base_get_iocstate(struct MPT3SAS_ADAPTER *ioc, int cooked)
 	sc = s & MPI2_IOC_STATE_MASK;
 	return cooked ? sc : s;
 }
+#if defined(CONFIG_SCSI_MPT3SAS_STM)
+EXPORT_SYMBOL(mpt3sas_base_get_iocstate);
+#endif
 
 /**
  * _base_wait_on_iocstate - waiting on a particular ioc state
@@ -3536,6 +3683,9 @@ mpt3sas_base_sas_iounit_control(struct MPT3SAS_ADAPTER *ioc,
 	mutex_unlock(&ioc->base_cmds.mutex);
 	return rc;
 }
+#if defined(CONFIG_SCSI_MPT3SAS_STM)
+EXPORT_SYMBOL(mpt3sas_base_sas_iounit_control);
+#endif
 
 /**
  * mpt3sas_base_scsi_enclosure_processor - sending request to sep device
@@ -3733,6 +3883,8 @@ _base_get_ioc_facts(struct MPT3SAS_ADAPTER *ioc, int sleep_flag)
 	facts->FWVersion.Word = le32_to_cpu(mpi_reply.FWVersion.Word);
 	facts->IOCRequestFrameSize =
 	    le16_to_cpu(mpi_reply.IOCRequestFrameSize);
+    facts->IOCMaxChainSegmentSize =
+        le16_to_cpu(mpi_reply.IOCMaxChainSegmentSize);
 	facts->MaxInitiators = le16_to_cpu(mpi_reply.MaxInitiators);
 	facts->MaxTargets = le16_to_cpu(mpi_reply.MaxTargets);
 	ioc->shost->max_id = -1;
@@ -4753,6 +4905,11 @@ mpt3sas_base_attach(struct MPT3SAS_ADAPTER *ioc)
 	_base_unmask_events(ioc, MPI2_EVENT_IR_OPERATION_STATUS);
 	_base_unmask_events(ioc, MPI2_EVENT_LOG_ENTRY_ADDED);
 	_base_unmask_events(ioc, MPI2_EVENT_TEMP_THRESHOLD);
+#if defined(CONFIG_SCSI_MPT3SAS_STM)
+    _base_unmask_events(ioc, MPI2_EVENT_SAS_INIT_DEVICE_STATUS_CHANGE);
+    _base_unmask_events(ioc, MPI2_EVENT_SAS_INIT_TABLE_OVERFLOW);
+    _base_unmask_events(ioc, MPI2_EVENT_HARD_RESET_RECEIVED);
+#endif
 
 	r = _base_make_ioc_operational(ioc, CAN_SLEEP);
 	if (r)
@@ -4801,7 +4958,7 @@ mpt3sas_base_detach(struct MPT3SAS_ADAPTER *ioc)
 {
 	dexitprintk(ioc, pr_info(MPT3SAS_FMT "%s\n", ioc->name,
 	    __func__));
-
+    
 	mpt3sas_base_stop_watchdog(ioc);
 	mpt3sas_base_free_resources(ioc);
 	_base_release_memory_pools(ioc);
@@ -4837,6 +4994,10 @@ _base_reset_handler(struct MPT3SAS_ADAPTER *ioc, int reset_phase)
 {
 	mpt3sas_scsih_reset_handler(ioc, reset_phase);
 	mpt3sas_ctl_reset_handler(ioc, reset_phase);
+#if defined(CONFIG_SCSI_MPT3SAS_STM)
+    if (stm_callbacks.reset_handler)
+        stm_callbacks.reset_handler(ioc, reset_phase);
+#endif
 	switch (reset_phase) {
 	case MPT3_IOC_PRE_RESET:
 		dtmprintk(ioc, pr_info(MPT3SAS_FMT
@@ -5031,3 +5192,6 @@ mpt3sas_base_hard_reset_handler(struct MPT3SAS_ADAPTER *ioc, int sleep_flag,
 	    __func__));
 	return r;
 }
+#if defined(CONFIG_SCSI_MPT3SAS_STM)
+EXPORT_SYMBOL(mpt3sas_base_hard_reset_handler);
+#endif
diff --git a/drivers/scsi/mpt3sas/mpt3sas_base.h b/drivers/scsi/mpt3sas/mpt3sas_base.h
index afa8816..92b3e9d 100644
--- a/drivers/scsi/mpt3sas/mpt3sas_base.h
+++ b/drivers/scsi/mpt3sas/mpt3sas_base.h
@@ -54,6 +54,7 @@
 #include "mpi/mpi2_raid.h"
 #include "mpi/mpi2_tool.h"
 #include "mpi/mpi2_sas.h"
+#include "mpi/mpi2_targ.h"
 
 #include <scsi/scsi.h>
 #include <scsi/scsi_cmnd.h>
@@ -88,6 +89,9 @@
 #define MPT3SAS_SG_DEPTH		MPT3SAS_MAX_PHYS_SEGMENTS
 #endif
 
+#if defined(CONFIG_SCSI_MPT3SAS_STM)
+#define NUM_CMD_BUFFERS    128
+#endif
 
 /*
  * Generic Defines
@@ -548,7 +552,7 @@ struct mpt3sas_facts {
 	u32			IOCCapabilities;
 	union mpi3_version_union	FWVersion;
 	u16			IOCRequestFrameSize;
-	u16			Reserved3;
+    u16			IOCMaxChainSegmentSize;
 	u16			MaxInitiators;
 	u16			MaxTargets;
 	u16			MaxSasExpanders;
@@ -957,11 +961,33 @@ struct MPT3SAS_ADAPTER {
 	struct SL_WH_EVENT_TRIGGERS_T diag_trigger_event;
 	struct SL_WH_SCSI_TRIGGERS_T diag_trigger_scsi;
 	struct SL_WH_MPI_TRIGGERS_T diag_trigger_mpi;
+    
+    void    *stmpriv;
 };
 
 typedef u8 (*MPT_CALLBACK)(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index,
 	u32 reply);
 
+#if defined(CONFIG_SCSI_MPT3SAS_STM)
+typedef void (*STM_CALLBACK_WITH_IOC)(struct MPT3SAS_ADAPTER *ioc);
+typedef void (*STM_CALLBACK_FOR_TGT_CMD)(struct MPT3SAS_ADAPTER *ioc,
+                                Mpi2TargetCommandBufferReplyDescriptor_t *rpf,
+                                u8 msix_index);
+typedef u8 (*STM_CALLBACK_FOR_TGT_ASSIST)(struct MPT3SAS_ADAPTER *ioc,
+                                Mpi2TargetAssistSuccessReplyDescriptor_t *rpf);
+typedef u8 (*STM_CALLBACK_FOR_SMID)(struct MPT3SAS_ADAPTER *ioc,
+                                u8 msix_index, u32 reply);
+typedef void (*STM_CALLBACK_FOR_RESET)(struct MPT3SAS_ADAPTER *ioc,
+                                int reset_phase);
+
+struct STM_CALLBACK {
+    STM_CALLBACK_WITH_IOC  watchdog;
+    STM_CALLBACK_FOR_TGT_CMD target_command;
+    STM_CALLBACK_FOR_TGT_ASSIST target_assist;
+    STM_CALLBACK_FOR_SMID event_handler;
+    STM_CALLBACK_FOR_RESET reset_handler;
+};
+#endif
 
 /* base shared API */
 extern struct list_head mpt3sas_ioc_list;
@@ -994,6 +1020,7 @@ void mpt3sas_base_put_smid_fast_path(struct MPT3SAS_ADAPTER *ioc, u16 smid,
 	u16 handle);
 void mpt3sas_base_put_smid_hi_priority(struct MPT3SAS_ADAPTER *ioc, u16 smid);
 void mpt3sas_base_put_smid_default(struct MPT3SAS_ADAPTER *ioc, u16 smid);
+void mpt3sas_base_put_smid_target(struct MPT3SAS_ADAPTER *ioc, u16 smid, u16 io_index);
 void mpt3sas_base_initialize_callback_handler(void);
 u8 mpt3sas_base_register_callback_handler(MPT_CALLBACK cb_func);
 void mpt3sas_base_release_callback_handler(u8 cb_idx);
@@ -1126,6 +1153,8 @@ int mpt3sas_config_get_volume_handle(struct MPT3SAS_ADAPTER *ioc, u16 pd_handle,
 	u16 *volume_handle);
 int mpt3sas_config_get_volume_wwid(struct MPT3SAS_ADAPTER *ioc,
 	u16 volume_handle, u64 *wwid);
+int mpt3sas_config_get_port_facts(struct MPT3SAS_ADAPTER *ioc, struct mpt3sas_port_facts *pfacts_copy);
+int mpt3sas_config_get_ioc_facts(struct MPT3SAS_ADAPTER *ioc, struct mpt3sas_facts *ifacts_copy);
 
 /* ctl shared API */
 extern struct device_attribute *mpt3sas_host_attrs[];
@@ -1177,4 +1206,12 @@ void mpt3sas_trigger_scsi(struct MPT3SAS_ADAPTER *ioc, u8 sense_key,
 	u8 asc, u8 ascq);
 void mpt3sas_trigger_mpi(struct MPT3SAS_ADAPTER *ioc, u16 ioc_status,
 	u32 loginfo);
+
+/* SCSI target mode module */
+#if defined(CONFIG_SCSI_MPT3SAS_STM)
+void mpt3sas_base_stm_initialize_callback_handler(void);
+void mpt3sas_base_stm_register_callback_handler(struct STM_CALLBACK stm_funcs);
+void mpt3sas_base_stm_release_callback_handler(void);
+#endif
+
 #endif /* MPT3SAS_BASE_H_INCLUDED */
diff --git a/drivers/scsi/mpt3sas/mpt3sas_config.c b/drivers/scsi/mpt3sas/mpt3sas_config.c
index e45c461..dac7faf 100644
--- a/drivers/scsi/mpt3sas/mpt3sas_config.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_config.c
@@ -1151,6 +1151,7 @@ mpt3sas_config_get_sas_iounit_pg1(struct MPT3SAS_ADAPTER *ioc,
  out:
 	return r;
 }
+EXPORT_SYMBOL(mpt3sas_config_get_sas_iounit_pg1);
 
 /**
  * mpt3sas_config_set_sas_iounit_pg1 - send sas iounit page 1
@@ -1195,6 +1196,7 @@ mpt3sas_config_set_sas_iounit_pg1(struct MPT3SAS_ADAPTER *ioc,
  out:
 	return r;
 }
+EXPORT_SYMBOL(mpt3sas_config_set_sas_iounit_pg1);
 
 /**
  * mpt3sas_config_get_expander_pg0 - obtain expander page 0
diff --git a/drivers/scsi/mpt3sas/mpt3sas_scsih.c b/drivers/scsi/mpt3sas/mpt3sas_scsih.c
index 5a97e32..0768b5c 100644
--- a/drivers/scsi/mpt3sas/mpt3sas_scsih.c
+++ b/drivers/scsi/mpt3sas/mpt3sas_scsih.c
@@ -8161,6 +8161,10 @@ _scsih_init(void)
 
 	mpt3sas_ctl_init();
 
+#if defined(CONFIG_SCSI_MPT3SAS_STM)
+    mpt3sas_base_stm_initialize_callback_handler();
+#endif
+    
 	error = pci_register_driver(&scsih_driver);
 	if (error) {
 		/* raid transport support */
@@ -8181,11 +8185,14 @@ _scsih_exit(void)
 {
 	pr_info("mpt3sas version %s unloading\n",
 	    MPT3SAS_DRIVER_VERSION);
-
+    
 	mpt3sas_ctl_exit();
 
 	pci_unregister_driver(&scsih_driver);
 
+#if defined(CONFIG_SCSI_MPT3SAS_STM)
+    mpt3sas_base_stm_release_callback_handler();
+#endif
 
 	mpt3sas_base_release_callback_handler(scsi_io_cb_idx);
 	mpt3sas_base_release_callback_handler(tm_cb_idx);
diff --git a/drivers/scsi/mpt3sas/mpt3sas_stm.c b/drivers/scsi/mpt3sas/mpt3sas_stm.c
new file mode 100644
index 0000000..8bf1374
--- /dev/null
+++ b/drivers/scsi/mpt3sas/mpt3sas_stm.c
@@ -0,0 +1,1628 @@
+/*
+ * Scsi Target Layer for MPT (Message Passing Technology) based controllers
+ *
+ * Copyright (C) 2015  Exact Assembly, LLC
+ *  (mailto:support@xassembly.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * NO WARRANTY
+ * THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR
+ * CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT
+ * LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is
+ * solely responsible for determining the appropriateness of using and
+ * distributing the Program and assumes all risks associated with its
+ * exercise of rights under this Agreement, including but not limited to
+ * the risks and costs of program errors, damage to or loss of data,
+ * programs or equipment, and unavailability or interruption of operations.
+ 
+ * DISCLAIMER OF LIABILITY
+ * NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
+ * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED
+ * HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES
+ 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
+ * USA.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kdev_t.h>
+#include <linux/blkdev.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/io.h>
+#include <linux/time.h>
+#include <linux/kthread.h>
+#include <linux/aer.h>
+
+#include "mpt3sas_base.h"
+#include "mpt3sas_stm.h"
+
+#define DPRINTK(fmt, args...) if (mpt3stm_debug) printk(KERN_DEBUG "%s: " fmt, \
+                                __FUNCTION__ , ## args)
+
+#ifdef VERBOSE
+#define VDPRINTK(fmt, args...) if (mpt3stm_debug) printk(KERN_DEBUG "%s: " fmt, \
+                                __FUNCTION__ , ## args)
+#else
+#define VDPRINTK(fmt, args...)
+#endif
+
+MODULE_AUTHOR(MPT3STM_AUTHOR);
+MODULE_DESCRIPTION(MPT3STM_DESCRIPTION);
+MODULE_LICENSE("GPL");
+MODULE_VERSION(MPT3STM_DRIVER_VERSION);
+
+int mpt3stm_debug = 0;
+module_param(mpt3stm_debug, int, S_IRUGO|S_IWUSR);
+MODULE_PARM_DESC(mpt3stm_debug, " enable debugging output ");
+
+struct _mpt3stm_ta {
+    struct _mpt3stm_ioc*    stmioc;
+    u16                     IoIndex;
+    
+    u16                     smid;
+    Mpi25TargetAssistRequest_t *mpi_request;
+    
+    struct scatterlist*     sg;
+    int                     nents;
+    enum dma_data_direction dir;
+    struct list_head        chain_list;
+    struct work_struct work_entry; // work_entry used by stmioc->recycleq add/remove
+};
+
+struct _mpt3stm_ioc {
+    struct MPT3SAS_ADAPTER *ioc;
+    void*               priv;   /* Client driver's pointer*/
+    MPT3STM_DISPATCH*   dispatch;
+    
+    u8                  enabled;
+    u8                  abort_all;
+    
+    struct list_head    phy_list;
+    
+    char                driver_name[MPT_NAME_LENGTH];
+    
+    u8                  stm_assist_cb_idx;
+    
+    u8                  stm_tm_cb_idx; /* task managment */
+    u8                  stm_tm_imm_cb_idx; /* immediate TM request */
+    u8                  stm_abort_cb_idx;
+    struct _internal_cmd stm_tm_cmds; /* TM requests */
+    
+    u8                  stm_post_cb_idx; /* post all buffers */
+    struct _internal_cmd stm_post_cmds; /* post cmd buffer request */
+    
+    u16                 ncmds;
+    MPT3STM_CMD_BUFF*   cmdbufs;
+    dma_addr_t          cmdbufs_dma;
+    
+    u16                 max_sges_in_ta_message;
+    u16                 max_sges_in_chain_segment;
+    spinlock_t          resource_lock;
+    
+    size_t              sge_chain_segment_size;
+    struct dma_pool     *ta_chain_dma_pool;
+    struct chain_tracker *ta_chain_lookup;
+    struct list_head    ta_free_chain_list;
+    
+    struct _mpt3stm_ta* ta_lookup;
+    struct workqueue_struct *recycleq; // work queue for returning commands to
+                                       // IOC
+    
+    u8                  ta_max_sges;
+    
+};
+
+static struct mpt3stm_ports _ports;
+
+static u8       _num_iocs;
+static struct _mpt3stm_ioc _iocs[MPT3STM_MAX_IOCS];
+
+
+/**
+ * _find_stmioc - turn the mpt3sas IOC pointer into our private target pointer
+ *
+ * Returns the private target pointer
+ */
+inline struct _mpt3stm_ioc*
+_ioc_to_stmioc( struct MPT3SAS_ADAPTER * const ioc )
+{
+    return (struct _mpt3stm_ioc*) ioc->stmpriv;
+}
+
+/**
+ * _to_iocidx - turn the private target pointer into an array index
+ *
+ * Returns the index of the stmioc pointer in the _iocs array
+ */
+inline u8
+_to_iocidx( struct _mpt3stm_ioc * const stmioc )
+{
+    return (u8) ((stmioc - _iocs)/sizeof(struct _mpt3stm_ioc));
+}
+
+inline struct _mpt3stm_ioc *
+_iocidx_to_ioc( u8 iocidx )
+{
+    BUG_ON( iocidx >= _num_iocs );
+    return &_iocs[iocidx];
+}
+
+
+union _mpt25target_request_union {
+    Mpi25TargetAssistRequest_t assist;
+    Mpi2TargetStatusSendRequest_t status;
+};
+
+
+
+
+
+//int _build_sg(struct MPT3SAS_ADAPTER *ioc,
+//              struct sg_table *sg_tbl, u32 smid, int rw, void *lsge, int main_sges)
+//{
+//    
+//}
+
+
+/* -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*- */
+/*      IOC Houskeeping                                                        */
+/* -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*- */
+
+/**
+ * @func _stm_msg_callback - command completion routine for oob (non I/O) messages
+ * @ioc: per adapter object
+ * @smid: system request message index
+ * @msix_index: MSIX table index supplied by the OS
+ * @reply: reply message frame(lower 32bit addr)
+ *
+ * Return 1 meaning mf should be freed from _base_interrupt
+ *        0 means the mf is freed from this function.
+ */
+static u8
+_stm_msg_callback(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index,
+                  u32 reply)
+{
+    
+    struct _mpt3stm_ioc *stmioc;
+    MPI2DefaultReply_t *mpi_reply;
+    
+    stmioc = _ioc_to_stmioc(ioc);
+    BUG_ON( !stmioc );
+    
+    if (stmioc->stm_post_cmds.status == MPT3_CMD_NOT_USED)
+    {
+        pr_err( MPT3SAS_FMT "%s that's odd, stm_post_cmds not used\n", ioc->name, __func__ );
+        return 1;
+    }
+    
+    mpi_reply = mpt3sas_base_get_reply_virt_addr(ioc, reply);
+    if (unlikely(!mpi_reply)) {
+        pr_err(MPT3SAS_FMT "mpi_reply not valid at %s:%d/%s()!\n",
+               ioc->name, __FILE__, __LINE__, __func__);
+        return 1;
+    }
+    
+    switch ( mpi_reply->Function ) {
+        case MPI2_FUNCTION_TARGET_CMD_BUF_BASE_POST:
+        case MPI2_FUNCTION_TARGET_CMD_BUF_LIST_POST:
+        case MPI2_FUNCTION_TARGET_MODE_ABORT:
+            break;
+        default:
+            pr_err( MPT3SAS_FMT "%s: Unknown function %x\n",
+                   ioc->name, __func__, mpi_reply->Function);
+            return 1;
+    }
+    
+    stmioc->stm_post_cmds.status &= ~MPT3_CMD_PENDING;
+    stmioc->stm_post_cmds.status |= MPT3_CMD_COMPLETE;
+    stmioc->stm_post_cmds.status |= MPT3_CMD_REPLY_VALID;
+    stmioc->stm_post_cmds.reply = kzalloc(mpi_reply->MsgLength*4, GFP_ATOMIC);
+    if ( stmioc->stm_post_cmds.reply )
+        memcpy(stmioc->stm_post_cmds.reply, mpi_reply, mpi_reply->MsgLength*4);
+    else
+        pr_err( MPT3SAS_FMT "%s: failed kzalloc\n",
+               ioc->name, __func__);
+    
+    complete(&stmioc->stm_post_cmds.done);
+    return 1;
+}
+
+
+/*
+ * @func _cmdbuf_base_post
+ * @brief Send a Command Buffer Post request
+ *
+ * @returns 0 or error code
+ */
+static int
+_cmdbuf_base_post(struct _mpt3stm_ioc *stmioc)
+{
+    struct MPT3SAS_ADAPTER *ioc;
+    Mpi2TargetCmdBufferPostBaseRequest_t *mpi_request = NULL;
+    U64* pBaseAddress;
+    Mpi2TargetCmdBufferPostBaseListReply_t *mpi_reply = NULL;
+    unsigned long timeleft;
+    int r = 0;
+    u16 smid;
+    u16 ioc_status;
+    
+    ioc = stmioc->ioc;
+    
+    if ( !stmioc->ncmds )
+        return -ENODEV;
+    
+    mutex_lock( &stmioc->stm_post_cmds.mutex );
+    if ( stmioc->stm_post_cmds.status & MPT3_CMD_PENDING ) {
+        pr_warn(MPT3SAS_FMT "%s(): internal command already in use?\n",
+               ioc->name, __func__);
+    }
+    stmioc->stm_post_cmds.status = MPT3_CMD_PENDING;
+    
+    smid = mpt3sas_base_get_smid(ioc, stmioc->stm_post_cb_idx);
+    if (!smid) {
+        pr_err(MPT3SAS_FMT "%s(): failed obtaining a smid\n",
+               ioc->name, __func__);
+        r = -EAGAIN;
+        goto out;
+    }
+    stmioc->stm_post_cmds.smid = smid;
+    
+    mpi_request = mpt3sas_base_get_msg_frame(ioc, smid);
+    if (unlikely(!mpi_request)) {
+        pr_err(MPT3SAS_FMT "%s(): mpi_request not valid\n",
+               ioc->name, __func__);
+        r = -ENOMEM;
+        goto out;
+    }
+    
+    memset(mpi_request, 0, sizeof(Mpi2TargetCmdBufferPostBaseRequest_t));
+    mpi_request->Function = MPI2_FUNCTION_TARGET_CMD_BUF_BASE_POST;
+    mpi_request->BufferPostFlags = MPI2_CMD_BUF_POST_BASE_FLAGS_AUTO_POST_ALL;
+    mpi_request->TotalCmdBuffers = cpu_to_le16( stmioc->ncmds );
+    mpi_request->CmdBufferLength = cpu_to_le16( sizeof(MPT3STM_CMD_BUFF) );
+    pBaseAddress = (u64*) &(mpi_request->BaseAddressLow);
+    *pBaseAddress =  cpu_to_le64( stmioc->cmdbufs_dma );
+    
+    init_completion(&stmioc->stm_post_cmds.done);
+    mpt3sas_base_put_smid_default(ioc, smid);
+    timeleft = wait_for_completion_timeout(&stmioc->stm_post_cmds.done,
+                                           100*HZ);
+    mutex_unlock( &stmioc->stm_post_cmds.mutex );
+    
+    if (!(stmioc->stm_post_cmds.status & MPT3_CMD_COMPLETE)) {
+        pr_err(MPT3SAS_FMT "%s(): timeout on wait_for_completion_timeout\n",
+               ioc->name, __func__);
+        _debug_dump_mf(mpi_request,
+                       sizeof(Mpi2PortEnableRequest_t)/4);
+        if (stmioc->stm_post_cmds.status & MPT3_CMD_RESET)
+            r = -EFAULT;
+        else
+            r = -ETIME;
+        goto out;
+    }
+    
+    mpi_reply = stmioc->stm_post_cmds.reply;
+    BUG_ON(!mpi_reply);
+    
+    ioc_status = (le16_to_cpu(mpi_reply->IOCStatus) & MPI2_IOCSTATUS_MASK);
+    if (ioc_status != MPI2_IOCSTATUS_SUCCESS) {
+        pr_err(MPT3SAS_FMT "%s(): failed with (ioc_status=0x%08x)\n",
+               ioc->name, __func__, ioc_status);
+        r = -EFAULT;
+        goto out;
+    }
+    
+out:
+    stmioc->stm_post_cmds.status = MPT3_CMD_NOT_USED;
+    stmioc->stm_post_cmds.reply = NULL;
+    VDPRINTK("complete\n");
+    return r;
+}
+
+/**
+ * @func _set_enable
+ * @returns 0 or error
+ */
+int
+_set_enable(struct _mpt3stm_ioc* stmioc,
+            int enable)
+{
+    Mpi2SasIOUnitPage1_t *sas_page1;
+    Mpi2ConfigReply_t mpi_reply;
+    struct _mpt3stm_phy *pphy;
+    int rc = 0;
+    
+    // check to see if needed
+    if (enable == stmioc->enabled)
+        return 0;
+    
+    sas_page1 = kzalloc(MPT3SAS_SASIOU1_SZ,
+                        GFP_KERNEL);
+    if ( !sas_page1 )
+    {
+        pr_err( MPT3SAS_FMT "%s(): failed kzmalloc\n",
+               stmioc->ioc->name, __func__);
+        return -ENOMEM;
+    }
+    
+    rc = mpt3sas_config_get_sas_iounit_pg1( stmioc->ioc,
+                                           &mpi_reply,
+                                           sas_page1,
+                                           MPT3SAS_SASIOU1_SZ);
+    
+    if (rc)
+    {
+        pr_err( MPT3SAS_FMT "%s(): failed mpt3sas_config_get_sas_iounit_pg1() with (iocstatus=0x%08x)\n",
+               stmioc->ioc->name, __func__,le16_to_cpu(mpi_reply.IOCStatus));
+        goto freeandexit;
+    }
+    
+    list_for_each_entry(pphy,&stmioc->phy_list,list)
+    {
+        VDPRINTK(" %sabling phy: %d\n", (enable ? "En" : "Dis"),
+                 pphy->phy_num);
+        if (enable) {
+            sas_page1->PhyData[pphy->phy_num].PhyFlags
+            &= ~MPI2_SASIOUNIT1_PHYFLAGS_PHY_DISABLE;
+        } else {
+            sas_page1->PhyData[pphy->phy_num].PhyFlags
+            |= MPI2_SASIOUNIT1_PHYFLAGS_PHY_DISABLE;
+        }
+    }
+    
+    memset( &mpi_reply,0,sizeof(Mpi2ConfigReply_t) );
+    rc = mpt3sas_config_set_sas_iounit_pg1( stmioc->ioc,
+                                           &mpi_reply,
+                                           sas_page1,
+                                           MPT3SAS_SASIOU1_SZ );
+    
+    if (rc)
+    {
+        pr_err( MPT3SAS_FMT "%s(): failed mpt3sas_config_set_sas_iounit_pg1() with (iocstatus=0x%08x)\n",
+               stmioc->ioc->name, __func__,le16_to_cpu(mpi_reply.IOCStatus));
+        goto freeandexit;
+    }
+    stmioc->enabled = enable;
+    
+freeandexit:
+    kfree(sas_page1);
+    return rc;
+}
+
+
+int
+_abort_all(struct _mpt3stm_ioc* stmioc)
+{
+    Mpi2TargetModeAbort_t	*mpi_request;
+    Mpi2TargetModeAbortReply_t *mpi_reply;
+    u16 smid, ioc_status;
+    int rc = 0;
+    
+    if ( !stmioc->ncmds )
+        return -ENODEV;
+    
+    if ( stmioc->stm_post_cmds.status & MPT3_CMD_PENDING ) {
+        pr_err(MPT3SAS_FMT "%s(): internal command already in use\n",
+               stmioc->ioc->name, __func__);
+        return -EAGAIN;
+    }
+    
+    smid = mpt3sas_base_get_smid(stmioc->ioc, stmioc->stm_abort_cb_idx);
+    if (!smid) {
+        pr_err(MPT3SAS_FMT "%s(): failed obtaining a smid\n",
+               stmioc->ioc->name, __func__);
+        rc = -EAGAIN;
+        goto out;
+    }
+    
+    mpi_request = mpt3sas_base_get_msg_frame(stmioc->ioc, smid);
+    if (unlikely(!mpi_request)) {
+        pr_err(MPT3SAS_FMT "%s(): mpi_request not valid\n",
+               stmioc->ioc->name, __func__);
+        rc = -ENOMEM;
+        goto out;
+    }
+    
+    stmioc->stm_post_cmds.status = MPT3_CMD_PENDING;
+    stmioc->stm_post_cmds.smid = smid;
+    stmioc->abort_all = 1;
+    
+    memset(mpi_request,0,sizeof(Mpi2TargetModeAbort_t));
+    mpi_request->Function = MPI2_FUNCTION_TARGET_MODE_ABORT;
+    mpi_request->AbortType = MPI2_TARGET_MODE_ABORT_ALL_CMD_BUFFERS;
+    
+    init_completion(&stmioc->stm_post_cmds.done);
+    mpt3sas_base_put_smid_default(stmioc->ioc, smid);
+    rc = wait_for_completion_interruptible(&stmioc->stm_post_cmds.done);
+    if (!(stmioc->stm_post_cmds.status & MPT3_CMD_COMPLETE)) {
+        pr_err(MPT3SAS_FMT "%s(): interrupted on wait_for_completion_interruptible\n",
+               stmioc->ioc->name, __func__);
+        _debug_dump_mf(mpi_request,
+                       sizeof(Mpi2TargetModeAbort_t)/4);
+        if (stmioc->stm_post_cmds.status & MPT3_CMD_RESET)
+            rc = -EFAULT;
+        else
+            rc = -ETIME;
+        goto out;
+    }
+    
+    stmioc->abort_all = 0;
+    mpi_reply = stmioc->stm_post_cmds.reply;
+    BUG_ON(!mpi_reply);
+    
+    ioc_status = (le16_to_cpu(mpi_reply->IOCStatus) & MPI2_IOCSTATUS_MASK);
+    if (ioc_status != MPI2_IOCSTATUS_SUCCESS) {
+        pr_err(MPT3SAS_FMT "%s(): failed with (ioc_status=0x%08x)\n",
+               stmioc->ioc->name, __func__, ioc_status);
+        rc = -EFAULT;
+    }
+    
+out:
+    stmioc->stm_post_cmds.status = MPT3_CMD_NOT_USED;
+    stmioc->stm_post_cmds.reply = NULL;
+    VDPRINTK("complete\n");
+    return rc;
+}
+
+int
+_post_command(struct _mpt3stm_ioc *stmioc, u16 IoIndex) {
+    Mpi2TargetCmdBufferPostListRequest_t *mpi_request = NULL;
+    Mpi2TargetCmdBufferPostBaseListReply_t *mpi_reply = NULL;
+    unsigned long timeleft;
+    int r = 0;
+    u16 smid;
+    u16 ioc_status;
+    
+    mutex_lock( &stmioc->stm_post_cmds.mutex );
+    if ( stmioc->stm_post_cmds.status & MPT3_CMD_PENDING ) {
+        pr_warn(MPT3SAS_FMT "%s(): internal command already in use?\n",
+                stmioc->ioc->name, __func__);
+    }
+    stmioc->stm_post_cmds.status = MPT3_CMD_PENDING;
+    
+    smid = mpt3sas_base_get_smid(stmioc->ioc, stmioc->stm_post_cb_idx);
+    if (!smid) {
+        pr_err(MPT3SAS_FMT "%s(): failed obtaining a smid\n",
+               stmioc->ioc->name, __func__);
+        r = -EAGAIN;
+        goto out;
+    }
+    stmioc->stm_post_cmds.smid = smid;
+    
+    mpi_request = mpt3sas_base_get_msg_frame(stmioc->ioc, smid);
+    if (unlikely(!mpi_request)) {
+        pr_err(MPT3SAS_FMT "%s(): mpi_request not valid\n",
+               stmioc->ioc->name, __func__);
+        r = -ENOMEM;
+        goto out;
+    }
+    
+    memset(mpi_request, 0, sizeof(Mpi2TargetCmdBufferPostBaseRequest_t));
+    mpi_request->Function = MPI2_FUNCTION_TARGET_CMD_BUF_LIST_POST;
+    //mpi_request->ChainOffset = 0;
+    mpi_request->CmdBufferCount = 1;
+    mpi_request->IoIndex[0] = IoIndex;
+    
+    init_completion(&stmioc->stm_post_cmds.done);
+    mpt3sas_base_put_smid_default(stmioc->ioc, smid);
+    timeleft = wait_for_completion_timeout(&stmioc->stm_post_cmds.done,
+                                           100*HZ);
+    mutex_unlock( &stmioc->stm_post_cmds.mutex );
+    if (!(stmioc->stm_post_cmds.status & MPT3_CMD_COMPLETE)) {
+        pr_err(MPT3SAS_FMT "%s(): timeout on wait_for_completion_timeout\n",
+               stmioc->ioc->name, __func__);
+        _debug_dump_mf(mpi_request,
+                       sizeof(Mpi2PortEnableRequest_t)/4);
+        if (stmioc->stm_post_cmds.status & MPT3_CMD_RESET)
+            r = -EFAULT;
+        else
+            r = -ETIME;
+        goto out;
+    }
+    
+    mpi_reply = stmioc->stm_post_cmds.reply;
+    BUG_ON(!mpi_reply);
+    
+    ioc_status = (le16_to_cpu(mpi_reply->IOCStatus) & MPI2_IOCSTATUS_MASK);
+    if (ioc_status != MPI2_IOCSTATUS_SUCCESS) {
+        pr_err(MPT3SAS_FMT "%s(): failed with (ioc_status=0x%08x)\n",
+               stmioc->ioc->name, __func__, ioc_status);
+        r = -EFAULT;
+        goto out;
+    }
+    
+out:
+    stmioc->stm_post_cmds.status = MPT3_CMD_NOT_USED;
+    stmioc->stm_post_cmds.reply = NULL;
+    VDPRINTK("complete\n");
+    return r;
+}
+
+
+
+/* -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*- */
+/*      Exposed API to caller modules                                          */
+/* -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*- */
+
+void
+mpt3stm_get_portmap( struct mpt3stm_ports * portmapbuffer )
+{
+    memcpy(portmapbuffer,&_ports,sizeof(_ports));
+}
+EXPORT_SYMBOL(mpt3stm_get_portmap);
+
+MPT3STM_CMD_BUFF*
+mpt3stm_get_cmdbuff(u8 iocidx,
+                        u16 ioidx)
+{
+    return &_iocidx_to_ioc(iocidx)->cmdbufs[ioidx];
+}
+EXPORT_SYMBOL(mpt3stm_get_cmdbuff);
+
+
+int mpt3stm_abort_all(u8 iocidx){
+    return _abort_all(_iocidx_to_ioc(iocidx));
+}
+EXPORT_SYMBOL(mpt3stm_abort_all);
+
+int mpt3stm_enable( u8 iocidx, u8 enable ) {
+    return _set_enable( _iocidx_to_ioc(iocidx), enable );
+}
+EXPORT_SYMBOL(mpt3stm_enable);
+
+int mpt3stm_is_enabled(u8 iocidx)
+{
+    return _iocidx_to_ioc(iocidx)->enabled;
+}
+EXPORT_SYMBOL(mpt3stm_is_enabled);
+
+int mpt3stm_register( u8 iocidx,
+                          MPT3STM_DISPATCH *dispatch ) {
+    _iocidx_to_ioc(iocidx)->dispatch = dispatch;
+    return 0;
+}
+EXPORT_SYMBOL(mpt3stm_register);
+
+void mpt3stm_deregister( u8 iocidx ) {
+    _iocidx_to_ioc(iocidx)->dispatch = NULL;
+}
+EXPORT_SYMBOL(mpt3stm_deregister);
+
+u16 mpt3stm_get_ncmds(u8 iocidx) {
+    return _iocidx_to_ioc(iocidx)->ncmds;
+}
+EXPORT_SYMBOL(mpt3stm_get_ncmds);
+
+// maximum number of sges is chain size +1 immediate in REQ
+u8 mpt3stm_get_max_sges(u8 iocidx) {
+    return _iocidx_to_ioc(iocidx)->ta_max_sges;
+}
+EXPORT_SYMBOL(mpt3stm_get_max_sges);
+
+u32 mpt3stm_get_iocstate(u8 iocidx, int cooked)
+{
+    struct _mpt3stm_ioc*    stmioc = _iocidx_to_ioc(iocidx);
+    struct MPT3SAS_ADAPTER* ioc = stmioc->ioc;
+    return mpt3sas_base_get_iocstate(ioc,cooked);
+}
+EXPORT_SYMBOL(mpt3stm_get_iocstate);
+
+char *mpt3stm_get_adapter_name(u8 iocidx)
+{
+    return MPT3SAS_DRIVER_NAME;
+}
+EXPORT_SYMBOL(mpt3stm_get_adapter_name);
+
+struct pci_dev *
+mpt3stm_get_pci_dev(u8 iocidx)
+{
+    struct _mpt3stm_ioc*    stmioc = _iocidx_to_ioc(iocidx);
+    struct MPT3SAS_ADAPTER* ioc = stmioc->ioc;
+    BUG_ON(!ioc);
+    return ioc->pdev;
+}
+EXPORT_SYMBOL(mpt3stm_get_pci_dev);
+
+void* mpt3stm_ioc_get_priv( u8 iocidx )
+{
+    return _iocidx_to_ioc(iocidx)->priv;
+}
+EXPORT_SYMBOL(mpt3stm_ioc_get_priv);
+
+void mpt3stm_ioc_set_priv( u8 iocidx, void* priv)
+{
+    _iocidx_to_ioc(iocidx)->priv = priv;
+}
+EXPORT_SYMBOL(mpt3stm_ioc_set_priv);
+
+
+
+int
+mpt3stm_remove_device(u8 iocidx, u16 DevHandle) {
+    struct _mpt3stm_ioc*        stmioc;
+    struct MPT3SAS_ADAPTER* ioc;
+    Mpi2SasIoUnitControlRequest_t mpi_request;
+    Mpi2SasIoUnitControlReply_t mpi_reply;
+    int r = 0;
+    
+    stmioc = _iocidx_to_ioc(iocidx);
+    ioc = stmioc->ioc;
+    memset(&mpi_request,0,sizeof(Mpi2SasIoUnitControlRequest_t));
+    
+    mpi_request.Function = MPI2_FUNCTION_SAS_IO_UNIT_CONTROL;
+    mpi_request.Operation = MPI2_SAS_OP_REMOVE_DEVICE;
+    mpi_request.DevHandle = cpu_to_le16( DevHandle );
+    
+    r = mpt3sas_base_sas_iounit_control(ioc,
+                                        &mpi_reply,
+                                        &mpi_request);
+    if (r) {
+        pr_err(MPT3SAS_FMT "%s: failed with (ioc_status=0x%08x)\n",
+               ioc->name, __func__, mpi_reply.IOCStatus);
+        
+        _debug_dump_mf(&mpi_request,sizeof(Mpi2SasIoUnitControlRequest_t)/4);
+        _debug_dump_reply(&mpi_reply,mpi_reply.MsgLength);
+        printk("==============\n");
+    }
+    
+    return r;
+}
+EXPORT_SYMBOL(mpt3stm_remove_device);
+
+int
+mpt3stm_send_status( u8 iocidx,
+                        u8 StatusFlags,
+                        u16 QueueTag,
+                        u16 InitiatorConnectionTag,
+                        u16 IoIndex) {
+    struct _mpt3stm_ioc*        stmioc;
+    struct MPT3SAS_ADAPTER* ioc;
+    u16 ts_smid;
+    Mpi2TargetStatusSendRequest_t* mpi_request;
+    int                     r = 0;
+
+    // We cannot be run from the IRQ context (softirq callback) because this
+    // interferes with interrupt enabling due to the use of an inline funciton
+    // for _writeq with a shared flags varibale for spin_lock_saveirq()!!
+    // we could fix the upstream LSI code in mpt3sas_base.c or just accept
+    // this as a restriction as is done here with BUG_ON()
+    BUG_ON(in_irq());
+    
+    stmioc = _iocidx_to_ioc(iocidx);
+    ioc = stmioc->ioc;
+    BUG_ON(!ioc);
+    
+    BUG_ON(!stmioc->stm_assist_cb_idx);
+    
+    ts_smid = mpt3sas_base_get_smid(ioc,stmioc->stm_assist_cb_idx);
+    if ( !ts_smid ) {
+        pr_err(MPT3SAS_FMT "%s: failed obtaining a smid\n",
+               stmioc->ioc->name, __func__);
+        r = -EAGAIN;
+        goto out;
+    }
+    
+    mpi_request = mpt3sas_base_get_msg_frame(ioc,ts_smid);
+    if (unlikely(!mpi_request)) {
+        pr_err(MPT3SAS_FMT "%s(): mpi_request not valid\n",
+               ioc->name, __func__);
+        mpt3sas_base_free_smid(ioc,
+                               ts_smid);
+        r = -ENOMEM;
+        goto out;
+    }
+    
+    memset(mpi_request, 0, sizeof(Mpi2TargetStatusSendRequest_t));
+    mpi_request->Function = MPI2_FUNCTION_TARGET_STATUS_SEND;
+    mpi_request->StatusFlags = StatusFlags;
+    mpi_request->QueueTag = cpu_to_le16(QueueTag);
+    mpi_request->InitiatorConnectionTag = cpu_to_le16(InitiatorConnectionTag);
+    mpi_request->IoIndex = cpu_to_le16(IoIndex);
+    mpi_request->SGLOffset0 = offsetof(Mpi2TargetStatusSendRequest_t, StatusDataSGE) / 4;
+    
+    mpi_request->StatusDataSGE.IeeeSimple.Simple64.Flags = MPI25_IEEE_SGE_FLAGS_END_OF_LIST;
+    mpi_request->StatusDataSGE.IeeeSimple.Simple64.Length = cpu_to_le32(sizeof(union _rsp_frame));
+    mpi_request->StatusDataSGE.IeeeSimple.Simple64.Address = cpu_to_le64(stmioc->cmdbufs_dma
+        + (sizeof(MPT3STM_CMD_BUFF) * IoIndex) + offsetof(MPT3STM_CMD_BUFF,rsp));
+        
+    mpt3sas_base_put_smid_target( ioc,
+                                  ts_smid,
+                                  IoIndex );
+    
+out:
+    return r;
+}
+EXPORT_SYMBOL(mpt3stm_send_status);
+
+/**
+ * _mpt3stm_get_chain_buffer_tracker - obtain chain tracker
+ * @ioc: per adapter object
+ * @smid: smid associated to an IO request
+ *
+ * Returns chain tracker(from ioc->free_chain_list)
+ */
+static struct chain_tracker *
+_mpt3stm_get_chain_buffer_tracker(struct _mpt3stm_ioc *stmioc, u16 IoIndex)
+{
+    struct chain_tracker *chain_req;
+    unsigned long flags;
+    
+    spin_lock_irqsave(&stmioc->resource_lock, flags);
+    if (list_empty(&stmioc->ta_free_chain_list)) {
+        spin_unlock_irqrestore(&stmioc->resource_lock, flags);
+        pr_err(MPT3SAS_FMT "%s: chain buffers not available\n",
+               stmioc->ioc->name, __func__);
+        return NULL;
+    }
+    chain_req = list_entry(stmioc->ta_free_chain_list.next,
+                           struct chain_tracker, tracker_list);
+    list_del_init(&chain_req->tracker_list);
+    list_add_tail(&chain_req->tracker_list,
+                  &stmioc->ta_lookup[IoIndex].chain_list);
+    spin_unlock_irqrestore(&stmioc->resource_lock, flags);
+    return chain_req;
+}
+
+/**
+ * _mpt3stm_add_sg_single_ieee - add sg element for IEEE format
+ * @paddr: virtual address for SGE
+ * @flags: SGE flags
+ * @chain_offset: number of 128 byte elements from start of segment
+ * @length: data transfer length
+ * @dma_addr: Physical address
+ *
+ * Return nothing.
+ */
+static void
+_mpt3stm_add_sg_single_ieee(void *paddr, u8 flags, u8 chain_offset, u32 length,
+                         dma_addr_t dma_addr)
+{
+    Mpi25IeeeSgeChain64_t *sgel = paddr;
+    
+    sgel->Flags = flags;
+    sgel->NextChainOffset = chain_offset;
+    sgel->Length = cpu_to_le32(length);
+    sgel->Address = cpu_to_le64(dma_addr);
+}
+
+static int
+_mpt3stm_build_sg_targetassist(struct _mpt3stm_ta *ta)
+{
+    struct MPT3SAS_ADAPTER *ioc = ta->stmioc->ioc;
+    dma_addr_t chain_dma;
+    struct scatterlist *sg_tacmd;
+    void *sg_local, *chain;
+    u32 chain_offset;
+    u32 chain_length;
+    int sges_left;
+    u32 sges_in_segment;
+    u8 simple_sgl_flags;
+    u8 simple_sgl_flags_last;
+    u8 chain_sgl_flags;
+    struct chain_tracker *chain_req;
+    
+    BUG_ON(!ioc);
+    
+    /* init scatter gather flags */
+    simple_sgl_flags = MPI2_IEEE_SGE_FLAGS_SIMPLE_ELEMENT |
+        MPI2_IEEE_SGE_FLAGS_SYSTEM_ADDR;
+    simple_sgl_flags_last = simple_sgl_flags |
+        MPI25_IEEE_SGE_FLAGS_END_OF_LIST;
+    chain_sgl_flags = MPI2_IEEE_SGE_FLAGS_CHAIN_ELEMENT |
+        MPI2_IEEE_SGE_FLAGS_SYSTEM_ADDR;
+    
+    sg_tacmd = ta->sg;
+    sges_left = dma_map_sg(&ioc->pdev->dev,
+                           ta->sg,
+                           ta->nents,
+                           ta->dir);
+    if (!sges_left) {
+        pr_err(MPT3SAS_FMT "%s: dma_map_sg failed\n",
+               ioc->name, __func__);
+        return -ENOMEM;
+    }
+    
+    sg_local = &ta->mpi_request->SGL;
+    sges_in_segment = ta->stmioc->max_sges_in_ta_message;
+    
+    if (sges_left <= sges_in_segment)
+        goto fill_in_last_segment;
+    
+    ta->mpi_request->ChainOffset = (sges_in_segment - 1 /* chain element */) +
+        (offsetof(Mpi25TargetAssistRequest_t, SGL)/ioc->sge_size_ieee);
+    
+    /* fill in main message segment when there is a chain following */
+    while (sges_in_segment > 1) {
+        _mpt3stm_add_sg_single_ieee(sg_local, simple_sgl_flags, 0,
+                                 sg_dma_len(sg_tacmd), sg_dma_address(sg_tacmd));
+        sg_tacmd = sg_next(sg_tacmd);
+        sg_local += ioc->sge_size_ieee;
+        sges_left--;
+        sges_in_segment--;
+    }
+    
+    /* initializing the pointers */
+    chain_req = _mpt3stm_get_chain_buffer_tracker(ta->stmioc, ta->IoIndex);
+    if (!chain_req)
+        return -1;
+    chain = chain_req->chain_buffer;
+    chain_dma = chain_req->chain_buffer_dma;
+    do {
+        sges_in_segment = (sges_left <=
+                           ta->stmioc->max_sges_in_chain_segment) ? sges_left :
+                            ta->stmioc->max_sges_in_chain_segment;
+        chain_offset = (sges_left == sges_in_segment) ?
+                            0 : sges_in_segment;
+        chain_length = sges_in_segment * ioc->sge_size_ieee;
+        if (chain_offset)
+            chain_length += ioc->sge_size_ieee;
+        _mpt3stm_add_sg_single_ieee(sg_local, chain_sgl_flags,
+                                 chain_offset, chain_length, chain_dma);
+        
+        sg_local = chain;
+        if (!chain_offset)
+            goto fill_in_last_segment;
+        
+        /* fill in chain segments */
+        while (sges_in_segment) {
+            _mpt3stm_add_sg_single_ieee(sg_local, simple_sgl_flags, 0,
+                                     sg_dma_len(sg_tacmd), sg_dma_address(sg_tacmd));
+            sg_tacmd = sg_next(sg_tacmd);
+            sg_local += ioc->sge_size_ieee;
+            sges_left--;
+            sges_in_segment--;
+        }
+        
+        chain_req = _mpt3stm_get_chain_buffer_tracker(ta->stmioc, ta->IoIndex);
+        if (!chain_req)
+            return -1;
+        chain = chain_req->chain_buffer;
+        chain_dma = chain_req->chain_buffer_dma;
+    } while (1);
+    
+    
+fill_in_last_segment:
+    
+    /* fill the last segment */
+    while (sges_left) {
+        if (sges_left == 1)
+            _mpt3stm_add_sg_single_ieee(sg_local,
+                                     simple_sgl_flags_last, 0, sg_dma_len(sg_tacmd),
+                                     sg_dma_address(sg_tacmd));
+        else
+            _mpt3stm_add_sg_single_ieee(sg_local, simple_sgl_flags, 0,
+                                     sg_dma_len(sg_tacmd), sg_dma_address(sg_tacmd));
+        sg_tacmd = sg_next(sg_tacmd);
+        sg_local += ioc->sge_size_ieee;
+        sges_left--;
+    }
+    
+    return 0;
+}
+
+void
+_mpt3stm_free_sg_targetassist(struct _mpt3stm_ta *ta)
+{
+    struct chain_tracker *chain_req, *next;
+    unsigned long flags;
+    
+    spin_lock_irqsave(&ta->stmioc->resource_lock, flags);
+    if (!list_empty(&ta->chain_list)) {
+        list_for_each_entry_safe(chain_req, next,
+                                 &ta->chain_list, tracker_list) {
+            list_del_init(&chain_req->tracker_list);
+            list_add(&chain_req->tracker_list,
+                     &ta->stmioc->ta_free_chain_list);
+        }
+    }
+    spin_unlock_irqrestore(&ta->stmioc->resource_lock, flags);
+    dma_unmap_sg(&ta->stmioc->ioc->pdev->dev,
+                 ta->sg,
+                 ta->nents,
+                 ta->dir);
+}
+
+int
+mpt3stm_assist( u8 iocidx, u8 AssistFlags, u16 QueueTag,
+               u16 InitiatorConnectionTag, u16 IoIndex, u8 SequenceNumber,
+               u32 SkipCount, u32 DataLength, struct scatterlist *sg,
+               int nents, enum dma_data_direction dir)
+{
+    struct _mpt3stm_ioc* stmioc = NULL;
+    struct _mpt3stm_ta *ta = NULL;
+    int rc = 0;
+    
+    stmioc = _iocidx_to_ioc(iocidx);
+    ta = &stmioc->ta_lookup[IoIndex];
+    BUG_ON(!ta);
+    
+    ta->smid = mpt3sas_base_get_smid(stmioc->ioc, stmioc->stm_assist_cb_idx);
+    if (unlikely(!ta->smid)) {
+        pr_err(MPT3SAS_FMT "%s: failed obtaining a smid\n",
+               stmioc->ioc->name, __func__);
+        rc = -EAGAIN;
+        goto out;
+    }
+    
+    ta->mpi_request = mpt3sas_base_get_msg_frame(stmioc->ioc, ta->smid);
+    BUG_ON(!ta->mpi_request);
+    
+    memset(ta->mpi_request, 0, sizeof(Mpi25TargetAssistRequest_t));
+    ta->mpi_request->Function = MPI2_FUNCTION_TARGET_ASSIST;
+    ta->mpi_request->TargetAssistFlags = AssistFlags;
+    ta->mpi_request->QueueTag = cpu_to_le16(QueueTag);
+    ta->mpi_request->InitiatorConnectionTag = cpu_to_le16(InitiatorConnectionTag);
+    ta->mpi_request->IoIndex = cpu_to_le16(IoIndex);
+    ta->mpi_request->SequenceNumber = SequenceNumber;
+    ta->mpi_request->DMAFlags = MPI25_TA_DMAFLAGS_OP_D_D_D_D; // all SGLs are data
+    ta->mpi_request->SGLOffset0 = offsetof(Mpi25TargetAssistRequest_t, SGL) / 4;
+    ta->mpi_request->SkipCount = cpu_to_le32(SkipCount);
+    ta->mpi_request->DataLength = cpu_to_le32(DataLength);
+
+    ta->sg = sg;
+    ta->nents = nents;
+    ta->dir = dir;
+    rc = _mpt3stm_build_sg_targetassist(ta);
+    if ( !rc )
+    {
+//        printk("TARGET_ASSIST=======\n");
+//        _debug_dump_mf(ta->mpi_request,
+//                       sizeof(union _mpt25target_request_union)/4);
+//        printk("=======TARGET_ASSIST\n");
+    
+        mpt3sas_base_put_smid_target(stmioc->ioc, ta->smid, IoIndex );
+    }
+out:
+    return rc;
+}
+EXPORT_SYMBOL(mpt3stm_assist);
+
+static void
+_recycle_cmd_on_workq(struct work_struct *work) {
+    struct _mpt3stm_ta* ta = container_of(work,struct _mpt3stm_ta,work_entry);
+    VDPRINTK(MPT3SAS_FMT "%s: release I:%04x on workq\n",
+             stmioc->ioc->name, __func__, ta->IoIndex);
+    _post_command(ta->stmioc,ta->IoIndex);
+}
+
+
+int
+mpt3stm_release_command(u8 iocidx, u16 IoIndex)
+{
+    struct _mpt3stm_ioc *stmioc = _iocidx_to_ioc(iocidx);
+    struct _mpt3stm_ta *ta;
+    BUG_ON(!stmioc);
+    
+    ta = &stmioc->ta_lookup[IoIndex];
+
+    INIT_WORK(&ta->work_entry, _recycle_cmd_on_workq);
+    queue_work(stmioc->recycleq, &ta->work_entry);
+    return 0;
+}
+EXPORT_SYMBOL(mpt3stm_release_command);
+
+
+/* -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*- */
+/*      Interface with mpt3sas_base                                            */
+/* -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*- */
+
+void
+_stm_watchdog_dispatch(struct MPT3SAS_ADAPTER *ioc)
+{
+    struct _mpt3stm_ioc *stmioc = _ioc_to_stmioc(ioc);
+    BUG_ON( !stmioc );
+    if (likely(stmioc->dispatch) && unlikely(stmioc->dispatch->stm_watchdog))
+        stmioc->dispatch->stm_watchdog(_to_iocidx(stmioc));
+    
+}
+
+
+/**
+ * _stm_command_dispatch - command buffer posted by IOC
+ * @ioc: per adapter object
+ * @rpf: reply descriptor
+ *
+ */
+void
+_stm_command_dispatch(struct MPT3SAS_ADAPTER *ioc,
+                      Mpi2TargetCommandBufferReplyDescriptor_t *rpf,
+                      u8 msix_index) {
+    struct _mpt3stm_ioc *stmioc;
+    
+    stmioc = _ioc_to_stmioc(ioc);
+    BUG_ON( !stmioc );
+    
+    if (likely(stmioc->dispatch) && likely(stmioc->dispatch->stm_command)) {
+        stmioc->dispatch->stm_command(_to_iocidx(stmioc),
+                                      (MPI2_RPY_DESCRIPT_TCB_FLAGS_PHYNUM_MASK & rpf->Flags),
+                                      le16_to_cpu(rpf->IoIndex), le16_to_cpu(rpf->InitiatorDevHandle));
+    } else {
+        pr_warn(MPT3SAS_FMT "%s: unable to dispatch command buffer!!\n",
+                stmioc->ioc->name,__func__);
+    }
+    
+}
+
+
+/**
+ * _stm_assist_err_callback - error completion for target assist messages (I/O)
+ * @ioc: per adapter object
+ * @smid: system request message index
+ * @msix_index: MSIX table index supplied by the OS
+ * @reply: reply message frame(lower 32bit addr)
+ *
+ * Return 1 meaning mf should be freed from _base_interrupt
+ *        0 means the mf is freed from this function.
+ */
+static u8
+_stm_assist_err_callback(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index,
+                            u32 reply)
+{
+    Mpi2TargetErrorReply_t* mpi_reply = NULL;
+    union _mpt25target_request_union* mpi_request = NULL;
+    struct _mpt3stm_ioc*    stmioc;
+    u16                     IoIndex;
+    
+    stmioc = _ioc_to_stmioc(ioc);
+    mpi_request = mpt3sas_base_get_msg_frame(ioc,smid);
+    
+    mpi_reply = mpt3sas_base_get_reply_virt_addr(ioc, reply);
+    BUG_ON(!mpi_reply);
+    
+    IoIndex = le16_to_cpu( mpi_reply->IoIndex );
+    
+    
+    pr_warn( MPT3SAS_FMT "%s: assist error IoIndex:%x with (iocstatus=0x%08x\n",
+            ioc->name, __func__,IoIndex,le16_to_cpu(mpi_reply->IOCStatus));
+    _debug_dump_mf(mpi_request,
+                   sizeof(union _mpt25target_request_union)/4);
+    _debug_dump_reply(&mpi_reply,mpi_reply->MsgLength);
+    
+    if (likely(stmioc->dispatch)) {
+        switch (mpi_request->assist.Function) {
+            case MPI2_FUNCTION_TARGET_ASSIST:
+                if (likely(stmioc->dispatch->stm_assist_complete))
+                    _mpt3stm_free_sg_targetassist(&stmioc->ta_lookup[IoIndex]);
+                    stmioc->dispatch->stm_assist_complete(_to_iocidx(stmioc),
+                                                          IoIndex,
+                                                          0, // no sequence number
+                                                          mpi_reply);
+                break;
+            case MPI2_FUNCTION_TARGET_STATUS_SEND:
+                if (likely(stmioc->dispatch->stm_status_complete))
+                    stmioc->dispatch->stm_status_complete(_to_iocidx(stmioc),
+                                                          IoIndex,
+                                                          mpi_reply);
+                break;
+            default:
+                pr_err( MPT3SAS_FMT "%s: invalid Function in callback error IoIndex:%x\n",
+                        ioc->name, __func__,IoIndex);
+                BUG_ON(1);
+        }
+    }
+    else
+    {
+        pr_err( MPT3SAS_FMT "%s(): no dispatch installed!\n",
+               ioc->name, __func__);
+    }
+    return 1;
+}
+
+/**
+ * _stm_assist_success_dispatch - successful completion for TARGET_ASSIST or
+ *                                  TARGET_STATUS message
+ * @ioc: per adapter object
+ * @rpf: reply descriptor frame
+ *
+ * Return 1 meaning mf should be freed from _base_interrupt
+ *        0 means the mf is freed from this function.
+ */
+u8
+_stm_assist_success_dispatch( struct MPT3SAS_ADAPTER *ioc,
+                             Mpi2TargetAssistSuccessReplyDescriptor_t *rpf )
+{
+    MPI2RequestHeader_t* mpi_request = NULL;
+    struct _mpt3stm_ioc *stmioc = _ioc_to_stmioc(ioc);
+    u16 IoIndex = le16_to_cpu( rpf->IoIndex );
+    BUG_ON(!stmioc);
+    
+    mpi_request = mpt3sas_base_get_msg_frame(ioc, rpf->SMID);
+    BUG_ON(!mpi_request);
+    
+    VDPRINTK("assist_success IoIndex:%x\n",rpf->IoIndex);
+
+    if (likely(stmioc->dispatch)) {
+        switch (mpi_request->Function) {
+            case MPI2_FUNCTION_TARGET_ASSIST:
+                if (likely(stmioc->dispatch->stm_assist_complete))
+                    _mpt3stm_free_sg_targetassist(&stmioc->ta_lookup[IoIndex]);
+                    stmioc->dispatch->stm_assist_complete(_to_iocidx(stmioc),
+                                                          IoIndex,
+                                                          rpf->SequenceNumber,
+                                                          NULL); // no err frame
+                break;
+            case MPI2_FUNCTION_TARGET_STATUS_SEND:
+                if (likely(stmioc->dispatch->stm_status_complete))
+                    stmioc->dispatch->stm_status_complete(_to_iocidx(stmioc),
+                                                          IoIndex,
+                                                          NULL); // no err frame
+                break;
+            default:
+                pr_err( MPT3SAS_FMT "%s: invalid Function in callback error IoIndex:%x\n",
+                       ioc->name, __func__,IoIndex);
+                BUG_ON(1);
+        }
+    }
+    else
+    {
+        pr_err( MPT3SAS_FMT "%s(): no dispatch installed!\n",
+               ioc->name, __func__);
+    }
+    return 1;
+}
+
+
+/**
+ * _stm_event_dispatch - EVENT notification, process, and pass along if necessary
+ * @ioc: per adapter object
+ * @msix_index: MSIX table index supplied by the OS
+ * @reply: reply message frame(lower 32bit addr)
+ *
+ */
+u8
+_stm_event_dispatch( struct MPT3SAS_ADAPTER *ioc,
+                    u8 msix_index,
+                    u32 reply)
+{
+    Mpi2EventNotificationReply_t* mpi_reply;
+    struct _mpt3stm_ioc *stmioc;
+    
+    /* events turned off due to host reset or driver unloading */
+    if (ioc->remove_host || ioc->pci_error_recovery)
+        return 0;
+    
+    
+    stmioc = _ioc_to_stmioc(ioc);
+    mpi_reply = mpt3sas_base_get_reply_virt_addr(ioc, reply);
+    BUG_ON(!mpi_reply);
+
+    if ( likely(stmioc->dispatch) && likely(stmioc->dispatch->stm_event) ) {
+        stmioc->dispatch->stm_event(_to_iocidx(stmioc),
+                                    mpi_reply);
+    } else {
+        pr_warn(MPT3SAS_FMT "%s: unable to dispatch event buffer!!\n",
+                stmioc->ioc->name,__func__);
+    }
+    
+    return 0;
+}
+
+/**
+ * _stm_reset_dispatch - Forward reset lifecycle information to STM client
+ *                          drivers
+ * @ioc: per adapter object
+ * @reset_phase: see mpt3sas_base.c
+ */
+void
+_stm_reset_dispatch(struct MPT3SAS_ADAPTER *ioc, int reset_phase)
+{
+    struct _mpt3stm_ioc *stmioc = _ioc_to_stmioc(ioc);
+    int rc;
+    
+    switch (reset_phase) {
+        case MPT3_IOC_PRE_RESET:
+            VDPRINTK("%s: MPT3_IOC_PRE_RESET\n",ioc->name);
+            break;
+        case MPT3_IOC_AFTER_RESET:
+            VDPRINTK("%s: MPT3_IOC_AFTER_RESET\n",ioc->name);
+            // terminate any CMD_BUFFER_POST
+            if (stmioc->stm_post_cmds.status & MPT3_CMD_PENDING) {
+                stmioc->stm_post_cmds.status |= MPT3_CMD_RESET;
+                mpt3sas_base_free_smid(ioc, stmioc->stm_post_cmds.smid);
+                complete(&stmioc->stm_post_cmds.done);
+            }
+            // terminate any TASK_MGMT
+            if (stmioc->stm_tm_cmds.status & MPT3_CMD_PENDING) {
+                stmioc->stm_tm_cmds.status |= MPT3_CMD_RESET;
+                mpt3sas_base_free_smid(ioc, stmioc->stm_tm_cmds.smid);
+                complete(&stmioc->stm_tm_cmds.done);
+            }
+            break;
+        case MPT3_IOC_DONE_RESET:
+            VDPRINTK("%s: MPT3_IOC_DONE_RESET\n",ioc->name);
+            // re-post the command buffers, otherwise no incoming commands
+            // can work
+            rc = _cmdbuf_base_post(stmioc);
+            if (rc)
+            {
+                pr_err(MPT3SAS_FMT "%s(): failed _cmdbuf_base_post()\n",
+                       ioc->name, __func__);
+            }
+            else
+            {
+                // re-enable the port if necessary
+                if (stmioc->enabled)
+                {
+                    _set_enable(stmioc,stmioc->enabled);
+                }
+            }
+            break;
+    }
+    
+    if ( likely(stmioc->dispatch) && likely(stmioc->dispatch->stm_reset) ) {
+        stmioc->dispatch->stm_reset(_to_iocidx(stmioc),
+                                    reset_phase);
+    } else {
+        pr_warn(MPT3SAS_FMT "%s: unable to dispatch reset activity!\n",
+                ioc->name,__func__);
+    }
+}
+
+
+/* -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*- */
+/*      Standard module glue                                                   */
+/* -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*- */
+
+void _stm_exit( void )
+{
+    int i;
+    struct _mpt3stm_ioc *stmioc;
+    struct _mpt3stm_phy *pphy, *nphy;
+    
+    mpt3sas_base_stm_release_callback_handler();
+    
+    for (i=0; i < MPT3STM_MAX_IOCS; i++)
+    {
+        stmioc = _iocidx_to_ioc(i);
+        
+        if (stmioc->ioc)
+        {
+            _abort_all(stmioc);
+            
+            mpt3sas_base_release_callback_handler(stmioc->stm_abort_cb_idx);
+            mpt3sas_base_release_callback_handler(stmioc->stm_post_cb_idx);
+            mpt3sas_base_release_callback_handler(stmioc->stm_assist_cb_idx);
+            
+            if (stmioc->ta_chain_lookup) {
+                for (i = 0; i < stmioc->ioc->chain_depth; i++) {
+                    if (stmioc->ta_chain_lookup[i].chain_buffer)
+                        pci_pool_free(stmioc->ta_chain_dma_pool,
+                                      stmioc->ta_chain_lookup[i].chain_buffer,
+                                      stmioc->ta_chain_lookup[i].chain_buffer_dma);
+                }
+                if (stmioc->ta_chain_dma_pool)
+                    pci_pool_destroy(stmioc->ta_chain_dma_pool);
+                kfree(stmioc->ta_chain_lookup);
+                stmioc->ta_chain_lookup = NULL;
+            }
+
+            if (stmioc->ta_lookup)
+                kfree(stmioc->ta_lookup);
+            
+            if (stmioc->stm_post_cmds.reply)
+                kfree(stmioc->stm_post_cmds.reply);
+            
+            if (stmioc->cmdbufs)
+                pci_free_consistent(stmioc->ioc->pdev,
+                                    (stmioc->ncmds * sizeof(MPT3STM_CMD_BUFF)),
+                                    stmioc->cmdbufs,
+                                    stmioc->cmdbufs_dma );
+            
+            list_for_each_entry_safe(pphy,nphy,&stmioc->phy_list,list)
+            {
+                list_del(&pphy->list);
+                kfree(pphy);
+            }
+            stmioc->ioc->stmpriv = NULL;
+            stmioc->ioc = NULL;
+        }
+        
+    }
+}
+
+struct STM_CALLBACK stm_callbacks = {
+    .watchdog = _stm_watchdog_dispatch,
+    .target_command = _stm_command_dispatch,
+    .target_assist = _stm_assist_success_dispatch,
+    .event_handler = _stm_event_dispatch,
+    .reset_handler = _stm_reset_dispatch,
+};
+
+/**
+ * @func _stm_init
+ * @brief Standard module entry routine, parses the list of IOCs
+ *
+ * @returns 0 or error code
+ */
+int _stm_init( void )
+{
+    struct MPT3SAS_ADAPTER *ioc;
+    struct _mpt3stm_ioc *stmioc;
+    Mpi2ConfigReply_t mpi_reply;
+    Mpi2SasIOUnitPage1_t *sas_page1 = NULL;
+    struct _mpt3stm_phy *pphy = NULL;
+    int i, rc = 0;
+    int last_port;
+    
+    _num_iocs = 0;
+    
+    memset(&_iocs,0,sizeof(_iocs));
+    mpt3sas_base_stm_register_callback_handler(stm_callbacks);
+    
+    list_for_each_entry(ioc, &mpt3sas_ioc_list, list) {
+
+        if (! ioc->facts.MaxInitiators )
+        {
+            pr_info(MPT3SAS_FMT "Target-Mode: skipped non-target enabled ioc\n",
+                    ioc->name);
+        }
+        else
+        {
+            stmioc = &_iocs[_num_iocs];
+            stmioc->ioc = ioc;
+            ioc->stmpriv = stmioc;
+            
+            if ( MPT3SAS_MAX_CMDBUFFS < ioc->pfacts[0].MaxPostedCmdBuffers )
+                stmioc->ncmds = MPT3SAS_MAX_CMDBUFFS;
+            else
+                stmioc->ncmds = ioc->pfacts[0].MaxPostedCmdBuffers;
+            
+            pr_info(MPT3SAS_FMT "Target Mode: Max Commands: %d, Max Initiators: %d\n",
+                    ioc->name, stmioc->ncmds, ioc->facts.MaxInitiators);
+            
+            INIT_LIST_HEAD( &stmioc->phy_list );
+            
+            // _internal_cmd structure used to control completions of MPI messages
+            stmioc->stm_post_cmds.status = MPT3_CMD_NOT_USED;
+            mutex_init(&stmioc->stm_post_cmds.mutex);
+            stmioc->stm_post_cmds.reply = kzalloc(ioc->reply_sz, GFP_KERNEL);
+            if ( !stmioc->stm_post_cmds.reply )
+            {
+                pr_err(MPT3SAS_FMT "%s(): failed kzmalloc\n",
+                       ioc->name, __func__);
+                rc = -ENOMEM;
+                goto errout;
+            }
+            spin_lock_init(&stmioc->resource_lock);
+            
+            // BIG memory allocations for the command buffers (incoming SSP frames) and
+            // outgoing returns (DMA addressable, PCI consistent)
+            stmioc->cmdbufs = pci_alloc_consistent(ioc->pdev,
+                                                   (stmioc->ncmds * sizeof(MPT3STM_CMD_BUFF)),
+                                                   &stmioc->cmdbufs_dma );
+            if (!stmioc->cmdbufs)
+            {
+                pr_err(MPT3SAS_FMT "%s(): failed pci_alloc_consistent ->cmdbufs\n",
+                       ioc->name, __func__);
+                rc = -ENOMEM;
+                goto errout;
+            }
+            
+            stmioc->recycleq = create_singlethread_workqueue( ioc->name ); // only one thing allowed to run at a time!
+            
+            stmioc->ta_lookup =
+                kzalloc(stmioc->ncmds * sizeof(struct _mpt3stm_ta), GFP_KERNEL);
+            if (!stmioc->ta_lookup)
+            {
+                pr_err(MPT3SAS_FMT "%s(): failed kzalloc ->ta_lookup\n",
+                       ioc->name, __func__);
+                rc = -ENOMEM;
+                goto errout;
+            }
+            for ( i=0; i < stmioc->ncmds; i++)
+            {
+                INIT_LIST_HEAD(&stmioc->ta_lookup[i].chain_list);
+                stmioc->ta_lookup[i].IoIndex = i;
+                stmioc->ta_lookup[i].stmioc = stmioc;
+            }
+            
+            // Another BIG memory allocation, this time for the
+            // SGL chains needed to map scatter gather lists in memory
+            if ( 0 == stmioc->ioc->facts.IOCMaxChainSegmentSize)
+            {
+                stmioc->sge_chain_segment_size = 0x160000;
+                pr_info(MPT3SAS_FMT "%s: 1MBy chains!\n",
+                        ioc->name, __func__);
+            }
+            else
+            {
+                stmioc->sge_chain_segment_size =
+                    stmioc->ioc->facts.IOCMaxChainSegmentSize * 16;
+                pr_info(MPT3SAS_FMT "%s: %04x chain segments (%x)\n",
+                        ioc->name, __func__,
+                        stmioc->sge_chain_segment_size,
+                        ioc->request_sz);
+            }
+            
+            stmioc->ta_chain_lookup =
+                kzalloc((ioc->chain_depth * sizeof(struct chain_tracker)),
+                    GFP_KERNEL);
+            if (!stmioc->ta_chain_lookup)
+            {
+                pr_err(MPT3SAS_FMT "%s(): failed kzalloc ->ta_chain_lookup\n",
+                    ioc->name, __func__);
+                rc = -ENOMEM;
+                goto errout;
+            }
+            
+            stmioc->ta_chain_dma_pool = pci_pool_create("target chain pool", ioc->pdev,
+                                                  stmioc->sge_chain_segment_size, 16, 0);
+            if (!stmioc->ta_chain_dma_pool) {
+                pr_err(MPT3SAS_FMT "ta_chain_dma_pool: pci_pool_create failed\n",
+                       ioc->name);
+                goto errout;
+            }
+            for (i = 0; i < ioc->chain_depth; i++) {
+                stmioc->ta_chain_lookup[i].chain_buffer = pci_pool_alloc(
+                    stmioc->ta_chain_dma_pool , GFP_KERNEL,
+                    &stmioc->ta_chain_lookup[i].chain_buffer_dma);
+                if (!stmioc->ta_chain_lookup[i].chain_buffer) {
+                    pr_err(MPT3SAS_FMT "ta_chain_dma_pool: pci_pool_alloc failed\n",
+                           ioc->name);
+                    goto errout;
+                }
+                //                total_sz += ioc->request_sz;
+            }
+//            pr_info(MPT3SAS_FMT
+//                "ta chain pool depth(%d), frame_size(%d), pool_size(%d kB)\n",
+//                ioc->name, stmioc->ta_chain_depth, ioc->request_sz,
+//                ((stmioc->ta_chain_depth *  ioc->request_sz))/1024);
+            
+            INIT_LIST_HEAD(&stmioc->ta_free_chain_list);
+            for (i = 0; i < ioc->chain_depth; i++)
+                list_add_tail(&stmioc->ta_chain_lookup[i].tracker_list,
+                              &stmioc->ta_free_chain_list);
+            
+            // how many SGL entries fit in the TargetAssist msg
+            stmioc->max_sges_in_ta_message = (ioc->request_sz -
+                offsetof(Mpi25TargetAssistRequest_t, SGL))/sizeof(Mpi25SGEIOUnion_t);
+            
+            // how many SGL entries fit in the SGL chains, 1 SGE is set aside
+            // for the chain element to cascade
+            stmioc->max_sges_in_chain_segment =
+                (stmioc->sge_chain_segment_size -
+                    sizeof(Mpi25SGEIOUnion_t))/sizeof(Mpi25SGEIOUnion_t);
+            
+            stmioc->ta_max_sges = (stmioc->max_sges_in_ta_message - 1) +
+                (stmioc->max_sges_in_chain_segment * ioc->facts.MaxChainDepth);
+            
+            pr_info(MPT3SAS_FMT "TA: Imm SGEs:%d, Max SGEs: %d\n",
+                    ioc->name, stmioc->max_sges_in_ta_message, stmioc->ta_max_sges);
+
+            
+            // Use SAS_IOUNIT_PAGE1 to map the available target ports and phys
+            sas_page1 = kzalloc(MPT3SAS_SASIOU1_SZ,
+                                GFP_KERNEL);
+            if ( !sas_page1 )
+            {
+                pr_err(MPT3SAS_FMT "%s(): failed kzmalloc\n",
+                       ioc->name, __func__);
+                rc = -ENOMEM;
+                goto errout;
+            }
+            rc = mpt3sas_config_get_sas_iounit_pg1( ioc,
+                                                   &mpi_reply,
+                                                   sas_page1,
+                                                   MPT3SAS_SASIOU1_SZ );
+            if (rc)
+            {
+                pr_err(MPT3SAS_FMT "%s():failed config_get_iounit_pg1 with (iocstatus=0x%08x)\n",
+                       ioc->name, __func__, le16_to_cpu(mpi_reply.IOCStatus));
+                goto errout;
+            }
+            
+            last_port = -1;
+            for ( i=0; i < sas_page1->NumPhys; i++ )
+            {
+                if ( MPI2_SAS_DEVICE_INFO_SSP_TARGET & sas_page1->PhyData[i].ControllerPhyDeviceInfo )
+                {
+                    if ( MPI2_SASIOUNIT1_PORT_FLAGS_AUTO_PORT_CONFIG & sas_page1->PhyData[i].PortFlags )
+                    {
+                        pr_warn(" HBA is misconfigured, target phy %d on autoconf port - ignored!!\n",i);
+                    }
+                    else
+                    {
+                        // allocate a phy tracking object
+                        pphy = kzalloc( sizeof(struct _mpt3stm_phy),
+                                       GFP_KERNEL );
+                        pphy->phy_num = i;
+                        pphy->port_num = sas_page1->PhyData[i].Port;
+                        pphy->phy_target_state = (MPI2_SASIOUNIT1_PHYFLAGS_PHY_DISABLE & sas_page1->PhyData[i].PhyFlags)?
+                            MPT3STM_PORT_STATE_DISABLED:MPT3STM_PORT_STATE_ENABLED;
+                        if (pphy->phy_target_state != stmioc->enabled)
+                        {
+                            VDPRINTK("setting ioc:%d phy:%d caused state change to %sbled\n",
+                                    _num_iocs,i,
+                                    (MPT3STM_PORT_STATE_ENABLED == pphy->phy_target_state)?"Ena":"Dis");
+                            stmioc->enabled = pphy->phy_target_state;
+                        }
+                        list_add_tail( &pphy->list,
+                                      &stmioc->phy_list );
+                        VDPRINTK(" phy: %d added to target list\n",i);
+                        if (sas_page1->PhyData[i].Port != last_port)
+                        {
+                            last_port = sas_page1->PhyData[i].Port;
+                            _ports.port[_ports.num_ports].PhysPort = sas_page1->PhyData[i].Port;
+                            _ports.port[_ports.num_ports].iocidx = _num_iocs;
+                            pr_info(MPT3SAS_FMT " port: %d added on ioc %d\n",
+                                    ioc->name,
+                                    _ports.num_ports,
+                                    _num_iocs);
+                            _ports.num_ports++;
+                        }
+                    }
+                }
+            }
+            kfree(sas_page1);
+            sas_page1 = NULL;
+            
+            // Register our callback routines with the MPI driver so it can route
+            // message completions to us
+            stmioc->stm_post_cb_idx = mpt3sas_base_register_callback_handler(_stm_msg_callback);
+            BUG_ON(!stmioc->stm_post_cb_idx);
+            stmioc->stm_abort_cb_idx = mpt3sas_base_register_callback_handler(_stm_msg_callback);
+            BUG_ON(!stmioc->stm_abort_cb_idx);
+            stmioc->stm_assist_cb_idx = mpt3sas_base_register_callback_handler(_stm_assist_err_callback);
+            BUG_ON(!stmioc->stm_assist_cb_idx);
+            
+            // Post the command buffer addresses to the IOC so that it can deliver
+            // SSP frames to us!
+            rc = _cmdbuf_base_post(stmioc);
+            if (rc)
+            {
+                pr_err(MPT3SAS_FMT "%s(): failed _cmdbuf_base_post()\n",
+                       ioc->name, __func__);
+                rc = -EFAULT;
+                goto errout;
+            }
+            
+            _num_iocs++;
+            
+        }
+
+    }
+    
+    return 0;
+    
+errout:
+    if (ioc)
+        ioc->stmpriv = NULL;
+    if (stmioc)
+        stmioc->ioc = NULL;
+    
+    if (sas_page1)
+        kfree(sas_page1);
+    
+    _stm_exit();
+    
+    return rc;
+}
+
+
+
+module_init(_stm_init);
+module_exit(_stm_exit);
+
diff --git a/drivers/scsi/mpt3sas/mpt3sas_stm.h b/drivers/scsi/mpt3sas/mpt3sas_stm.h
new file mode 100644
index 0000000..c35d6ff
--- /dev/null
+++ b/drivers/scsi/mpt3sas/mpt3sas_stm.h
@@ -0,0 +1,357 @@
+/*
+ * SCSI Target Layer for MPT2.5 (Message Passing Technology) based controllers
+ *
+ * Copyright (C) 2015  Exact Assembly, LLC
+ *  (mailto:support@xassembly.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * NO WARRANTY
+ * THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR
+ * CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT
+ * LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is
+ * solely responsible for determining the appropriateness of using and
+ * distributing the Program and assumes all risks associated with its
+ * exercise of rights under this Agreement, including but not limited to
+ * the risks and costs of program errors, damage to or loss of data,
+ * programs or equipment, and unavailability or interruption of operations.
+ 
+ * DISCLAIMER OF LIABILITY
+ * NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
+ * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ * USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED
+ * HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES
+ 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
+ * USA.
+ */
+
+#ifndef MPT3SAS_TARGET_H_INCLUDED
+#define MPT3SAS_TARGET_H_INCLUDED
+
+#include "mpi/mpi2_type.h"
+#include "mpi/mpi2.h"
+#include "mpi/mpi2_ioc.h"
+#include "mpi/mpi2_sas.h"
+#include "mpi/mpi2_targ.h"
+
+#include <scsi/scsi.h>
+#include <linux/scatterlist.h>
+#include <linux/workqueue.h>
+
+/* driver versioning info */
+#define MPT3STM_DRIVER_NAME		"mpt3stm"
+#define MPT3STM_AUTHOR          "Exact Assembly, LLC <info@xassembly.com>"
+#define MPT3STM_DESCRIPTION         "LSI SAS 3.0 SCSI Target Driver"
+#define MPT3STM_DRIVER_VERSION		"04.100.00.00"
+#define MPT3STM_MAJOR_VERSION		4
+#define MPT3STM_MINOR_VERSION		100
+#define MPT3STM_BUILD_VERSION		0
+#define MPT3STM_RELEASE_VERSION     00
+
+
+#define SAS_DATAPRES_NODATA     0
+#define SAS_DATAPRES_RESPONSE   1
+#define SAS_DATAPRES_SENSE      2
+
+#define SAS_SSP_FRAMETYPE_TASK  (0x16)
+#define SAS_SSP_FRAMETYPE_CMD   (0x06)
+
+/**
+ * @struct MPT3STM_DISPATCH
+ * @brief A copy of this struct is required for mpt3stm_register, and it consists of
+ *      a set of function callbacks used to dispatch asynch firmware events,
+ *      asynchronous target mode command buffers, and to process the returns from MPT3
+ *      commands
+ * @member stm_event - This callback occurs when a firmware (MPT2) event
+ *      occurs, for example a TOPOLOGY_CHANGE event, allowing the TGT consumer to
+ *      respond to firmware events and even filter them if necessary, the callback
+ *      function returns a 0 to indicate that the event should be filtered, 1 otherwise
+ * @member stm_command - This callback occurs when a remote host sends a
+ *      command to us
+ * @member stm_assist_complete - This callback occurs when a TARGET_ASSIST
+ *                          command is completed, if the command failed then
+ *                          the mpi_reply field is a pointer to the frame, NULL
+ *                          otherwise
+ * @member stm_status_complete - This callback occurs when a TARGET_STATUS
+ *                          command is completed, if the command failed then
+ *                          the mpi_reply field is a pointer to the frame, NULL
+ *                          otherwise
+ * @member stm_watchdog - The driver internal watchdog loop will dispatch to
+ *                          this routine whenever it is called to allow the
+ *                          client to detect internal lockups.
+ * @member stm_reset- The driver internal reset logic notifies us when it is
+ *                          invoked, pass along to client.
+ *
+ * @member target_msg_complete - This callback occurs when a TARGET_ABORT/REPOST command is
+ *      completed (the reply frame is the originally submitted smid)
+ * @member driver - human readable name of the attached driver
+ */
+typedef struct {
+    void  (*stm_event) (u8 iocidx, MPI2_EVENT_NOTIFICATION_REPLY *pevent);
+    void (*stm_command) (u8 iocidx, u8 PhyNum, u16 IoIndex,
+                         u16 InitiatorDevHandle);
+    void (*stm_assist_complete) (u8 iocidx, u16 IoIndex, u8 IOCSequenceNum,
+                                 Mpi2TargetErrorReply_t* mpi_reply);
+    void (*stm_status_complete) (u8 iocidx, u16 IoIndex,
+                                 Mpi2TargetErrorReply_t* mpi_reply);
+    void (*stm_watchdog) (u8 iocidx);
+    void (*stm_reset) (u8 iocidx, int reset_phase);
+    char driver[32];
+} MPT3STM_DISPATCH;
+
+// number of bytes in a command frame coming from IOC - see MPT2.5 spec
+#define MPT3STM_CMD_BYTES   (64)
+// number of bytes in a response buffer going to IOC - see MPT2.5 spec
+#define MPT3STM_RSP_BYTES   (192)
+
+/* The IOC writes either a COMMAND type frame or a TASK type frame when
+   posting a SCSI target command buffer */
+union _cmd_frame {
+    u8 bytes[MPT3STM_CMD_BYTES];
+    Mpi2TargetSspCmdBuffer  command;
+    Mpi2TargetSspTaskBuffer task;
+};
+
+union _rsp_frame {
+    u8 bytes[MPT3STM_RSP_BYTES];
+    Mpi2TargetSspRspIu_t rspiu;
+};
+
+/* We allocate a set of command/response frames in DMA accessible/PCI memory
+   so that the IOC can send us commands and we can send back reply (SCSI status) */
+typedef struct {
+    union _cmd_frame  cmd;
+    union _rsp_frame  rsp;
+    struct list_head   recycle_list;
+} MPT3STM_CMD_BUFF;
+
+#define MPT3STM_PORT_STATE_DISABLED    (0)
+#define MPT3STM_PORT_STATE_ENABLED     (1)
+
+#define MPT3STM_MAX_PORTS           (8)
+#define MPT3STM_MAX_IOCS            (8)
+
+struct mpt3stm_port {
+    u8          PhysPort;
+    u16         PhyNum;
+    u8          iocidx;
+};
+
+struct mpt3stm_ports {
+    uint        num_ports;
+    struct mpt3stm_port port[MPT3STM_MAX_PORTS];
+};
+
+#define MPT3SAS_MAX_CMDBUFFS    (128)
+#define MPT3SAS_SASIOU1_SZ (sizeof(Mpi2SasIOUnitPage1_t) + sizeof(MPI2_SAS_IO_UNIT1_PHY_DATA)*15)
+
+// forward decl
+struct _mpt3stm_ioc;
+
+struct _mpt3stm_phy {
+    u8 port_num;
+    u8 phy_num;
+    u8 phy_target_state;
+    struct list_head list;
+};
+
+/* flags definitions */
+#define MPT3STM_FLAGS_REPOST	0x01		/* repost command buffer */
+#define MPT3STM_FLAGS_WRITE     0x02		/* this is a write request */
+#define MPT3STM_FLAGS_STATUS	0x04		/* indicate good status */
+
+
+/* SCSI target-mode API */
+/**
+ * @func mpt3stm_get_adapter_name
+ * @brief Get our IOC adapter name
+ *
+ * @param iocidx - ioc index for dispatch
+ *
+ * @return pointer to adapter name of ioc
+ */
+char *mpt3stm_get_adapter_name(u8 iocidx);
+/**
+ * @func pli2tgt_get_pci_device
+ * @brief Get our IOC adapter name
+ *
+ * @param iocidx - ioc index for dispatch
+ *
+ * @return pointer to struct pci_dev or NULL
+ */
+struct pci_dev *mpt3stm_get_pci_dev(u8 iocidx);
+
+
+/**
+ * @func mpt3sas_base_get_iocstate
+ * @brief Get our IOC doorbell register
+ *
+ * @param iocidx - ioc index for dispatch
+ * @param cooked 0 for raw value, 1 for masked (IOCState)
+ *
+ * @return value of doorbell register
+ */
+u32 mpt3stm_get_iocstate(u8 iocidx, int cooked);
+
+/**
+ * @func: mpt3stm_get_cmdbuff
+ * @brief This function call gives the target driver access to the command
+ *          buffer used for incoming command frames and outgoing response
+ *          frames.
+ *
+ * @param ioidx The IOC assigned IoIndex
+ * @returns a pointer to the command/response buffer
+ */
+MPT3STM_CMD_BUFF* mpt3stm_get_cmdbuff(u8 iocidx, u16 ioidx);
+
+/**
+ * @func mpt3stm_get_portmap
+ * @brief Get our port mapping information message for the driver
+ *
+ * @param portmapbuffer pointer to an allocated buffer to hold the mapping
+ */
+void mpt3stm_get_portmap( struct mpt3stm_ports * portmapbuffer );
+
+void* mpt3stm_ioc_get_priv( u8 iocidx );
+void mpt3stm_ioc_set_priv( u8 iocidx, void* priv);
+
+int mpt3stm_register(u8 iocidx, MPT3STM_DISPATCH *dispatch );
+void mpt3stm_deregister( u8 iocidx );
+
+/**
+ * @func mpt3stm_enable
+ * @brief Enable or disable STM functionality on an IOC
+ *
+ * @param iocidx the mpt3stm assigned IOC index number reported in portmap
+ * @enable: 0 to disable, 1 to enable
+ *
+ * @returns 0 or error code
+ */
+int mpt3stm_enable(u8 iocidx, u8 enable );
+
+/**
+ * @func mpt3stm_is_enabled
+ * @brief Check to see if target ports are enabled
+ *
+ * @param iocidx the mpt3stm assigned IOC index number reported in portmap
+ *
+ * @returns 1 if the IOC target PHYs have been enabled
+ */
+int mpt3stm_is_enabled(u8 iocidx);
+
+/**
+ * @func mpt3stm_get_iocfacts
+ * @brief Get our IOC Facts message for the driver
+ *
+ * @param iocidx - ioc index for dispatch
+ * @param *buff pointer to the MPI2_IOCFACTS_REPLY buffer
+ *
+ */
+int mpt3stm_get_iocfacts(u8 iocidx, MPI2_IOC_FACTS_REPLY *pIOCFacts);
+
+/**
+ * @func mpt3stm_get_ncmds
+ * @brief Get the number of command buffers needed
+ *
+ * @param iocidx the mpt3stm assigned IOC index number reported in portmap
+ * @returns - the number of command buffers the IOC expects
+ */
+u16 mpt3stm_get_ncmds(u8 iocidx);
+
+/**
+ * @func mpt3stm_get_max_sges
+ * @brief Get the maximum number of SGEs handleable in a TargetAssist
+ *
+ * @param iocidx the mpt3stm assigned IOC index number reported in portmap
+ * @returns - the number of SGL entries the driver can support
+ */
+u8 mpt3stm_get_max_sges(u8 iocidx);
+
+/**
+ * @func mpt3stm_remove_device
+ * @brief Issue the correct SAS IOUNIT CONTROL command to clear the IOC data
+ *          structures associated with this DevHandle (required when a device
+ *          is reported Not-Responding)
+ * @param
+ */
+int mpt3stm_remove_device(u8 iocidx, u16 DevHandle);
+
+/**
+ * @func mpt3sas_stm_abort_all
+ * @brief Send a Command Buffer Post request
+ *
+ * @param iocidx the mpt3stm assigned IOC index number reported in portmap
+ * @returns 0 or error code
+ */
+int mpt3stm_abort_all(u8 iocidx);
+
+/**
+ * @func mpt3stm_release_command
+ * @brief Return a target command buffer to the IOC for later use
+ *
+ * @param iocidx The STM assigned ioc ID
+ * @param IoIndex the ID of the SSP frame this response corresponds to
+ *
+ * @returns 0 - success, else error
+ */
+int
+mpt3stm_release_command(u8 iocidx, u16 IoIndex);
+
+/**
+ * @func mpt3stm_send_status
+ * @brief Create and post a target status request
+ *
+ * @param portid The STM assigned port ID
+ * @param StatusFlags MPT2.5 specified
+ * @param QueueTag Defined by SCSI SAM-4 (set to 0 if not a tagged command)
+ * @param InitiatorConnectionTag from the incoming SSP frame
+ * @param IoIndex the ID of the SSP frame this response corresponds to
+ *
+ * @returns 0 - success, else error
+ */
+int
+mpt3stm_send_status(u8 iocidx, u8 StatusFlags, u16 QueueTag,
+    u16 InitiatorConnectionTag, u16 IoIndex );
+
+/**
+ * @func mpt3stm_assist
+ * @brief Create and post a target assist request
+ *
+ * @param iocidx the index of the IOC as reported in port_map
+ * @param StatusFlags
+ * @param QueueTag
+ * @param InitiatorConnectionTag
+ * @param IoIndex
+ * @param SequenceNumber
+ * @param SkipCount
+ * @param DataLength
+ * @param sg
+ * @param nents
+ * @param dir
+ *
+ * @returns 0 - success, else error
+ */
+int
+mpt3stm_assist( u8 iocidx, u8 AssistFlags, u16 QueueTag,
+               u16 InitiatorConnectionTag, u16 IoIndex, u8 SequenceNumber,
+               u32 SkipCount, u32 DataLength, struct scatterlist *sg,
+               int nents, enum dma_data_direction dir);
+
+#endif // MPT3SAS_TARGET_H_INCLUDED
+
+
